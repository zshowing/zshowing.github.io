<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Design &amp; Code</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zshowing.github.io/"/>
  <updated>2022-04-16T09:39:32.203Z</updated>
  <id>http://zshowing.github.io/</id>
  
  <author>
    <name>Jon Showing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一代人有一代人的运动</title>
    <link href="http://zshowing.github.io/2022/04/15/Every-Generation-Has-Its-Movement/"/>
    <id>http://zshowing.github.io/2022/04/15/Every-Generation-Has-Its-Movement/</id>
    <published>2022-04-15T03:08:44.000Z</published>
    <updated>2022-04-16T09:39:32.203Z</updated>
    
    <content type="html"><![CDATA[<p>朋友们，事情已经很清楚了：这是一场运动。</p><p>对，就是你我在书里曾经看到过的那种。没赶上上一次，我们终于在2022又有缘得见。</p><p>我是在大概4月10号意识到这一点的。之前看到的各种视频/图片包括但不限于：</p><ul><li>吉林长春，防疫人员强行进入民居消杀，毁坏居民财物；</li><li>江西上饶、吉林长春、上海等多地，以消杀之名虐杀居民宠物；</li><li>地点不明的多地农村，强令农民回家，不许整地；</li><li>上海将婴幼儿与母亲强行分离隔离；</li><li>吉林、上海发生多起强行要求核酸证明而延误急诊治疗的事件；</li><li>上海戴“党员突击队”袖章的流氓不让孕妇出小区就诊并动手打人；</li><li>香河、廊坊、常州、镇江等地侵犯跨城上班公民的通行自由强行加码……</li></ul><p>当然，后面还出现了更多的录音和视频，各种只为了执行命令泯灭人性的例子。</p><p>引起我警觉的是它们的共有规律，即最底层有一点小权力，甚至只是穿个<strong>防护服、保安装或戴个红袖章</strong>的<strong>普通人</strong>，就能以“防疫”这个<strong>最高纲领</strong>对你的<strong>一切权利</strong>进行<strong>无限侵犯</strong>。<br>这听起来是不是和曾经的那段日子完全一致？</p><p>法治消失了。物权不见了。人权也不管了（如果之前有过的话）。<br>清零。只有这一件事是<strong>头等大事</strong>。</p><p>哪怕母亲和孩子一同隔离都不行，因为会多一个数字。<br>哪怕做法完全不科学也不管，因为是上边的指示。<br>甚至哪怕天平的另一面是活生生的生命也不可以。<br>有的在民怨沸腾之后会松动一下，更多的不仅不见改，还每天各种击破下限。</p><p>我之前一直以为至少以后再也不会有影响到每个人的那种运动了，他们内部怎么折腾都无所谓。可事实证明，之前只是没有类似“清零”的这种“<strong>最高意志</strong>”而已，它的土壤一直都在，而且看起来会一直存在下去。<br>谁又能想得到下一个“最高意志”会是什么呢？</p><p>前一阵听到官媒有个宣传口径叫“一代人有一代人的长征”（考虑到”长征“其实是路线失败后的补救措施，这个口号还挺诅咒的），按照这个思路，也许更应该说“<strong>一代人有一代人的运动</strong>”。<br>最早的那一代不提了，我们的上一代赶上的叫“计划生育”，同样是血泪满满。而且如果你仔细想的话，它同样是完全不考虑科学性，最后一直到出生人口跌到毛少将都能看出完蛋了才掩耳盗铃般地松动一点。<br>到我们这一代，这个运动就是<strong>大清零</strong>。</p><p>注意，我甚至没有说这个政策是完全错误的，要知道计划生育在它制定之初也是有实际道理的。咱们把决策层面的科学因素放下不谈，即使只谈执行，它也许<strong>本意</strong>是好的，但它把优先级和紧迫性调得太高，调子定的太死，以至于在执行中一定会出层出不穷的问题。这是<strong>客观规律</strong>。顺便一提，这也是所有极端左派在天真改造世界时的通病。</p><p>我们是花了多大代价才总结出“<strong>实事求是</strong>”这四个字的？</p><p>我喜爱的重轻老师的评价也类似：<br>￼<br><img src="https://i.imgtg.com/2022/04/16/kwFXU.png" alt="IMG-2439.png"></p><p>没错，“人 is irrelevant”。<br>接下来将会继续发生各种神奇的事情。“人 is irrelevant”，“经济 is irrelevant”，“物资 is irrelevant”，everything is irrelevant.<br>Except the number. The target is ZERO.<br>在发生任何神奇事情的时候，想一下这句话，就什么都能理解了。</p><p>值得指出的是，在这过程中，还会有许多对“既要xx又要xx”的奇怪公文。它们的共同特点是，每一对都<strong>无法同时实现</strong>，只能其中一条成为衡量政绩的硬指标，另一条成为防民之口的免责声明。</p><p>如果只因为觉得灾害没蔓延到自己脸上就觉得这没什么，或者，如果只觉得只有新闻报得出来的地方有问题，那我替云南瑞丽，黑龙江黑河，河北廊坊，辽宁营口等无数封到崩溃的地方谢谢你，替抖音上刷出的无数因为神经病加码政策五六个小时开几百米、出高速后还要被封条和铁丝关在驾驶室不让离开的货车司机谢谢你，谢谢你，因为有你，他们还会继续。</p><p>为老百姓祈祷，愿计划生育的那种破防拐点尽快到来，让我们可以用理性的态度，审视真实的数据，讨论科学的做法。</p><p>实事求是。</p><p>￼<br><img src="https://i.imgtg.com/2022/04/16/kwixY.jpg" alt="IMG-2439.png"></p>]]></content>
    
    <summary type="html">
    
      朋友们，事情已经很清楚了：这是一场运动。
    
    </summary>
    
      <category term="观察" scheme="http://zshowing.github.io/categories/%E8%A7%82%E5%AF%9F/"/>
    
    
      <category term="观察" scheme="http://zshowing.github.io/tags/%E8%A7%82%E5%AF%9F/"/>
    
      <category term="时事" scheme="http://zshowing.github.io/tags/%E6%97%B6%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>《寻找天堂》- Podcast「Jon&#39;s Story」Vol. 01</title>
    <link href="http://zshowing.github.io/2019/05/07/podcast-jons-story-vol-01/"/>
    <id>http://zshowing.github.io/2019/05/07/podcast-jons-story-vol-01/</id>
    <published>2019-05-07T09:15:22.000Z</published>
    <updated>2019-05-07T15:04:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2rpcm5basj218y0tn4qq.jpg" alt=""></p><p>难以想象，我居然录了一期播客。</p><p>虽然磕磕绊绊，虽然一个开头就录了小四十次，虽然在剪辑时删了大概有两亿个「嗯」、「然后」和空白（以至于到最后我可以凭肉眼识别出「嗯」的波形），虽然即使这样最终的成品质量也不咋地……</p><p>但是tmd，我这种连发微信语音的次数都能用一个手数出来的人，居然录出了一期完整的播客！</p><p>我好了。</p><hr><p>之前虽然对自己的说话能力之差有心理准备（这也是这档播客录制的初衷），但到真正录制的时候，还是被吓了一跳。之前我认为自己最大的问题是没法连续说出很长的话（比如3分钟以上），以及对和人分享事情这件事缺乏练习，直到我听到了自己说出的话：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2rrd8zr71j21du0vy0ve.jpg" alt=""></p><p>（Anderson同学说这是「聊天障碍可视化」……）</p><p>基本是在一个个地往外蹦语素，说话这个模块20年没升级真的是不行。</p><hr><p>最终完成的场景（2019.5.7，凌晨1:21）：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2suvwkzi4j23402c01kz.jpg" alt=""></p><p>一共加起来有40分钟左右，花的时间相比之下完全不成比例。</p><p>但是，这也算是一个还算可以的起步了。</p><p>感谢豆瓣网友aloveyn，是看到她的评论之后，我才想到请虚拟主播这个点子。有个人捧哏让录音听起来顺畅了许多，而且神奇地恰好契合了这期播客故事的核心。</p><p>详情可以移步：<a href="https://music.163.com/#/program?id=2061026510">https://music.163.com/#/program?id=2061026510</a></p><hr><p>接下来的选题包括：</p><ul><li>科幻小说；</li><li>英国 / 台湾骑行；</li><li>…</li></ul><p>由于主要目的还是练习说话，可能（其实是希望）慢慢地会日常化：）</p><p>下台鞠躬！</p>]]></content>
    
    <summary type="html">
    
      播客「Jon&#39;s Story」第一期，介绍游戏《寻找天堂》。
    
    </summary>
    
      <category term="Podcast" scheme="http://zshowing.github.io/categories/Podcast/"/>
    
    
      <category term="Podcast" scheme="http://zshowing.github.io/tags/Podcast/"/>
    
      <category term="Jon&#39;s Story" scheme="http://zshowing.github.io/tags/Jon-s-Story/"/>
    
      <category term="游戏" scheme="http://zshowing.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Remember the Pain</title>
    <link href="http://zshowing.github.io/2019/04/29/feeling-pain/"/>
    <id>http://zshowing.github.io/2019/04/29/feeling-pain/</id>
    <published>2019-04-28T17:14:51.000Z</published>
    <updated>2019-04-30T06:13:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇应该会写得相对简短，因为我翻阅了之前写的三篇类似总结，对其中的结论和其后的真正应对已经非常失望。但我又不能不写——毕竟，直到对一件事的思考落实成文字，我才会放过它，然后带着这些结论向前走。</p><p>之前在微信公众号用了《双城记》这个典故，并且借用了它那著名的开头来描述我的三月。事实上2019年至今也是同样的，我经历了这辈子最开心的一个多月，也经历了这辈子最痛的现在，而且对什么时候能走出它没有预期。</p><p>更可气的就是在写这篇之前翻阅之前文章的时候，我发现那些结论，最早的在2013年时，我已经心知肚明，然而这次依然在重复。</p><p>依然没法放松。依然缺失一些独立人格。依然不会聊天。等等。</p><p>现在想来，似乎我之前想到的解决方案是这个：找到一个能让我安心做自己的人（见2017.1.28文章）。事实上这事在2017年确实做到了，但又被我亲手掐断了，因为我到底无法安心接受自己不够喜欢对方这件事。</p><p>所以，把希望寄托在这种小概率事件上是不靠谱的。不能指望你深深喜欢的人恰好就是能够悉心包容你的人——没有任何人有这个义务。这件事一定要从自身方向改起，无论如何，至少要好好地把自己展示出来。</p><p>这几天想到的一些零碎的方向如下：</p><ol><li>归根结底，放松来源于气场，气场来源于自信，自信来源于对自己满意。如果自己没有做成一个让自己满意的人，这些又如何谈起呢？（打算在近期尽快辞职）</li><li>正如我在豆瓣状态提到的，聊天这件事可以看做一项系统工程来改善。如果说在饭桌或者桌游活跃最难的话，那最简单的起步就是和0个人聊——也就是做podcast的讲故事节目。我真的至今都很少在聊天中说连续3分钟以上的话，也完全没有把最近的经历分享给别人的意识，这个项目可以看作是一个契机。（仍在考虑）</li><li>和人交往时所表现出的一定是自己最好状态的子集，所以你能做的只有拓展你的集合广度和深度，不存在「和其他人都聊不来，除了你」这种情况，一定是「和大部分人都能聊聊，但尤其是你」。后者才是合理的恋爱场景，前者叫tmd奇迹。（多和人聊天，多体会不同的生活和话题，留意锻炼分享这项技能）</li></ol><p>这些方法看似有点过度反应，但几乎是我能想到唯一治本的办法了，这个远儿是不得不绕的。</p><p>虽然我很看不上之前的文字，但此处还是想引用一段（2017年1月）：</p><blockquote><p>而要达到这点有几种途径：1.对方很主动（而我不一定喜欢）；2.我的智商碾压对方（而我当然不一定喜欢）；3.我们交往的时间足够长，长到我用亲身经历确认了上面这点（而我不一定能撑到这个阶段）。</p></blockquote><p>——你看，这个机灵劲儿抖的，是不是把自己未来两年的事儿全都预言了=v=</p><p>真的，要记住这个痛感呀。</p>]]></content>
    
    <summary type="html">
    
      可能只有痛感，才能使人走出舒适区。
    
    </summary>
    
      <category term="Life" scheme="http://zshowing.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://zshowing.github.io/tags/Life/"/>
    
      <category term="Love" scheme="http://zshowing.github.io/tags/Love/"/>
    
      <category term="总结" scheme="http://zshowing.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Project 「Crossroads」</title>
    <link href="http://zshowing.github.io/2019/04/26/project-Crossroads/"/>
    <id>http://zshowing.github.io/2019/04/26/project-Crossroads/</id>
    <published>2019-04-25T18:12:00.000Z</published>
    <updated>2019-04-28T15:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有了一个新的设计项目构想，所以想在这个项目完成之前，先把之前（唯一的……）一个系列作品补发上来：</p><p>Project「Crossroads」。</p><p>（这个名字顺便致敬了我最爱的专辑之一，Bon Jovi 的同名精选集<Crossroads>）</p><p>这个系列完全是无意中的发现，可能要到2014年香港的那张照拍完后，整理照片时我才猛然意识到：我怎么这么喜欢这个拍摄角度……然后才翻出了之前几年拍的那几张。并且在随后的几年里，才开始有意识地选取同样角度进行拍摄。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hgycsb7tj21e00xckjl.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hh1binyxj21gt0tsqv5.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2isbgr61wj21mc12whdt.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjhivie2j21mc12wkjl.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjcvktwqj218h0tmu0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjayhi2qj21mc12we81.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjbr0g19j21e00xdu0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hje0opiij21e00xdnpd.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjcch85tj21e00xdqv5.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjdgp9eej20xc1e0npd.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjj23eeij215o1qikjp.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjke3u3vj215o1qiqv9.jpg" alt=""></p><p>松本的这两张是在同一个路口，拍摄时间相隔一天——第二天早上起来发现下雪了，把我高兴坏了，然后忙不迭回到了前一天拍摄的地点……</p><p>之前做的图停留在了2015年松本的这两张，本来印象里后面就开始克制这个系列的创作了——因为不想太过刻意地重复自己，然而在编辑这篇文章的时候又把后面的照片稍微翻了翻（很可能不全），发现还是忍不住拍了不少……</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjfytjsgj21mc12wx6p.jpg" alt=""></p><p align="center">（东京银座）</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjkz8vqtj21uo18gu0x.jpg" alt=""></p><p align="center">(The Big Ben)</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjb990lzj21mc12wqv5.jpg" alt=""></p><p align="center">（英国Cotswolds地区）</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjew32mgj215o1jku0x.jpg" alt=""></p><p align="center">（熊本城）</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjfmo4jfj21mc12wu0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjfar8c6j21mc12wqv5.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjbin29gj21mc12whdt.jpg" alt=""></p><hr><p>插几句引申话题。</p><p>刚开始编辑这篇文章的时候，正好赶上生日。</p><p>然后还是挺感慨的……不仅前几天正好刚刚走过一个人生的 crossroad（虽然是完全出乎意料的那个方向……），而且想来接下来也差不多到主动选择走人生的哪条路的时刻了。</p><p>然后我<del>念了两句诗</del>做了个海报：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1g2hjtv0zyej21mc2907db.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      「Crossroads」项目，是一组摄影作品集。
    
    </summary>
    
      <category term="摄影" scheme="http://zshowing.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="旅行" scheme="http://zshowing.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="Design" scheme="http://zshowing.github.io/tags/Design/"/>
    
      <category term="摄影" scheme="http://zshowing.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>公司周报点赞关系的数据可视化尝试</title>
    <link href="http://zshowing.github.io/2017/06/30/The-like-relationship-of-Qiyu/"/>
    <id>http://zshowing.github.io/2017/06/30/The-like-relationship-of-Qiyu/</id>
    <published>2017-06-30T15:58:06.000Z</published>
    <updated>2017-06-30T16:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前一阵，在和小段同学聊天时，我们拿每周要交的周报下面互相点赞的文化开玩笑，比如一个小团体间会互相吹捧，比如某些人会狂给别人点赞（点赞狂魔）等等。然后我突然想到前一阵看过一篇把唐朝诗人间互相提及的数据进行可视化的文章<a href="http://www.guokr.com/article/442052/">《计算机告诉你，唐朝诗人之间的关系到底什么样？》</a>，跟这是完全类似的场景。于是我的好奇心起，如果对公司里的汇报进行一番分析，结果会是什么样呢？再加上我本就一直对数据可视化感兴趣，正好趁机练练手。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1fh3ompk8cwj20qk0jy76e.jpg" alt="盛唐时期诗人关系图"><br>图：《计算机告诉你，唐朝诗人之间的关系到底什么样？》中盛唐时期的诗人关系图</p><h2 id="数据准备和初步统计"><a href="#数据准备和初步统计" class="headerlink" title="数据准备和初步统计"></a>数据准备和初步统计</h2><p>首先要做的自然是爬数据，借助瑞士军刀般好用的Python（和requests库），这个过程乏善可陈。首先我调用请求汇报列表的接口拿到了3000条汇报的id（时间跨度大约是从2016年11月初到2017年6月末），然后慢慢地一条一条拿这3000条汇报的详情，并建了个数据库保存在本地。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1fh33a95p9bj21200n644f.jpg" alt=""></p><p>然后我们就能写代码了。其中最简单的就是点赞数和被点赞数的排行，只要简单地加起来即可：</p><table><thead><tr><th>姓名</th><th>被点赞数</th></tr></thead><tbody><tr><td>郝思阳</td><td>296</td></tr><tr><td>李增辉</td><td>254</td></tr><tr><td>濮智光</td><td>233</td></tr><tr><td>何亮</td><td>226</td></tr><tr><td>张硕</td><td>224</td></tr><tr><td>杨培玉</td><td>218</td></tr><tr><td>杜庆</td><td>204</td></tr><tr><td>杨嘉琦</td><td>203</td></tr><tr><td>李雪然</td><td>201</td></tr></tbody></table><table><thead><tr><th>姓名</th><th>点赞数</th></tr></thead><tbody><tr><td>李增辉</td><td>2557</td></tr><tr><td>濮智光</td><td>615</td></tr><tr><td>吴凯</td><td>602</td></tr><tr><td>张敏</td><td>602</td></tr><tr><td>杨培玉</td><td>440</td></tr><tr><td>黄家辉</td><td>364</td></tr><tr><td>方语微</td><td>335</td></tr><tr><td>胡燕玲</td><td>308</td></tr><tr><td>郑立宝</td><td>296</td></tr></tbody></table><p>事先我和小段同学对前几名先进行了猜想，基本被程序跑出来的结果印证。包括万人迷——设计组的郝思阳，点赞狂魔——测试组的李增辉。当然还有些出乎意料的，主要是和自己没什么交集的人，比如我们猜出了点赞数615的濮智光，但点赞数602的吴凯和张敏我们却完全没想到。以及点赞数排在前面的人，在被点赞数列表里很多都能看到，说明这也存在礼尚往来的问题，辛苦就会得到回报xD</p><p>然后就是一些更细粒度的分析，比如具体到每个人，被谁点赞最多：</p><table><thead><tr><th>姓名</th><th>被别人点赞前两名</th></tr></thead><tbody><tr><td>胡燕玲</td><td>李增辉, 30; 濮智光, 28</td></tr><tr><td>夏轩</td><td>李增辉, 28; 张敏, 22</td></tr><tr><td>吴呈邑</td><td>张敏, 29; 李增辉, 28</td></tr><tr><td>韩君男</td><td>李增辉, 28; 罗宇翔, 16</td></tr></tbody></table><p>很快会发现，这个表被前面点赞数最多的几个人的霸榜了……去除他们之后的数据更有意义一些：</p><table><thead><tr><th>姓名</th><th>被别人点赞前三名（去除李增辉濮智光）</th></tr></thead><tbody><tr><td>胡燕玲</td><td>杨培玉, 23; 郑明君, 19; 张硕, 18;</td></tr><tr><td>夏轩</td><td>张敏, 22; 郑晓洛, 21; 魏定阔, 17;</td></tr><tr><td>吴呈邑</td><td>张敏, 29; 宋忠森, 18; 吴凯, 14;</td></tr><tr><td>韩君男</td><td>罗宇翔, 16; 段宏思, 7; 张敏, 6;</td></tr></tbody></table><h2 id="引入Plotly图形库"><a href="#引入Plotly图形库" class="headerlink" title="引入Plotly图形库"></a>引入Plotly图形库</h2><p>在网上搜到的图形库中看上去最好看的就是<a href="https://plot.ly">Plotly</a>，我研究了一下，发现三维可拖动的效果虽然看上去高大上，但实际并不直观，也没法灵活配置参数（比如每条线的粗细，每个圆的大小等等），我能达到的最好效果大概就是下面这样：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1fh360g8lvfj20ob0jomyy.jpg" alt=""></p><p>其中最明显的就是最上面给产品老大点赞的一群销售/实施，下面产品设计部的关系并不明显。</p><p>上面这个图的地址是：<a href="https://plot.ly/~JonShowing9266/0/the-like-relation-of-qiyu-weibangong/">https://plot.ly/~JonShowing9266/0/the-like-relation-of-qiyu-weibangong/</a></p><p>于是我去找来了上面那篇唐朝诗人关系图的源码，在它的基础上改了一下，终于有了比较满意的结果。</p><h2 id="引入ECharts图形库"><a href="#引入ECharts图形库" class="headerlink" title="引入ECharts图形库"></a>引入ECharts图形库</h2><p><a href="echarts.baidu.com/examples.html">ECharts</a>是个前端的图形库，最开始我研究了半天怎么在Python上直接用这个库，最后实在没搞懂才转投Plotly。经过对上面源码的分析，我发现其实只要用Python拼一下ECharts所需要的JavaScript代码就行了，最终直接生成HTML文件。</p><p>结果大概是这样的：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1fh367veohij21bw0tp7ez.jpg" alt=""></p><p>这里对数据做了个预处理：首先是读取了上面提到的每个人给别人点赞的排序列表，且只取前三个的数据，这样可以有效降低互相间点赞关系过于混乱的情况，又能把握最主要的动向；第二是只取赞数大于5的数据，如果没到5说明两人间的关系不明显，可以忽略。</p><p>经过上面的处理，此时其实互相间的关系已经比较明显了，接下来我又做了个简单的聚类，就是把互相之间点赞数大于5的人放到一组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group = []</span><br><span class="line">picked = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> likeUniqueArray:</span><br><span class="line">    ppl = peopleMap[pid]</span><br><span class="line">    <span class="keyword">for</span> like <span class="keyword">in</span> ppl.getLikes():</span><br><span class="line">        <span class="keyword">if</span> like[<span class="number">1</span>] &gt; <span class="number">5</span>: </span><br><span class="line">            <span class="comment"># only calculate the ones whose like count is greater than 5</span></span><br><span class="line">            found = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> subGroup <span class="keyword">in</span> group:</span><br><span class="line">                <span class="keyword">if</span> pid <span class="keyword">in</span> subGroup <span class="keyword">or</span> like[<span class="number">0</span>] <span class="keyword">in</span> subGroup: </span><br><span class="line">                    <span class="comment"># check both ppl and target, </span></span><br><span class="line">                    <span class="comment"># if found any of the two, check if it is valid</span></span><br><span class="line">                    found = <span class="literal">True</span></span><br><span class="line">                    notInGroup = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> subGroup:</span><br><span class="line">                        <span class="keyword">if</span> item == pid <span class="keyword">or</span> item == like[<span class="number">0</span>]: </span><br><span class="line">                            <span class="comment"># skip item itself</span></span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        anotherPPL = peopleMap[item]</span><br><span class="line">                        <span class="keyword">if</span> anotherPPL.getLikeValue(pid) &lt; <span class="number">5</span> <span class="keyword">or</span> anotherPPL.getLikeValue(like[<span class="number">0</span>]) &lt; <span class="number">5</span>: </span><br><span class="line">                            <span class="comment"># total like count reversely</span></span><br><span class="line">                            notInGroup = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> notInGroup <span class="keyword">and</span> <span class="keyword">not</span> (pid <span class="keyword">in</span> picked <span class="keyword">and</span> like[<span class="number">0</span>] <span class="keyword">in</span> picked):</span><br><span class="line">                        subGroup.add(pid)</span><br><span class="line">                        subGroup.add(like[<span class="number">0</span>])</span><br><span class="line">                        picked.append(pid)</span><br><span class="line">                        picked.append(like[<span class="number">0</span>])</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> (pid <span class="keyword">in</span> picked <span class="keyword">and</span> like[<span class="number">0</span>] <span class="keyword">in</span> picked):</span><br><span class="line">                s = <span class="built_in">set</span>([pid])</span><br><span class="line">                s.add(like[<span class="number">0</span>])</span><br><span class="line">                picked.append(pid)</span><br><span class="line">                picked.append(like[<span class="number">0</span>])</span><br><span class="line">                group.append(s)</span><br></pre></td></tr></table></figure><p>代码写得仓促，看起来比较恶心，但效果很明显：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1fh369lvvjuj20jm0dh0x6.jpg" alt=""></p><p>上图的填色就是基于这个分组的。</p><p>把上图人工画一下分组，大概是：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79ly1fh36chfnrnj21hc0u0dtk.jpg" alt=""></p><p>可以说，我们得到了和唐朝诗人关系图那篇文章中相同的结论，即使对这个公司没有任何了解，仅仅凭借对点赞关系的分析，就能大致还原组织架构图。</p><p>最终效果图的地址是：<a href="http://jonshowing.com/like-network/output.html">http://jonshowing.com/like-network/output.html</a></p>]]></content>
    
    <summary type="html">
    
      对公司周报下同事互相的点赞关系尝试进行了数据可视化，得出了一些有趣的结论。
    
    </summary>
    
      <category term="数据可视化" scheme="http://zshowing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="数据可视化" scheme="http://zshowing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="Python" scheme="http://zshowing.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一个统一的返回样式方案</title>
    <link href="http://zshowing.github.io/2016/12/08/A-Unified-Back-Button-Solution/"/>
    <id>http://zshowing.github.io/2016/12/08/A-Unified-Back-Button-Solution/</id>
    <published>2016-12-07T17:12:35.000Z</published>
    <updated>2016-12-07T17:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手了一个已经开发了几年的项目，里面各种风格的代码都有，很多时候会看到完成同一件事，不同的人会调用截然不同的“公用”方法。</p><p>恰好赶上产品设计团队有一个在产品内部统一返回样式的任务，让我有机会可以在一个整体的高度上完整地考虑这一小块的问题。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>经过对现有代码的搜索和整理，当前工程中在设置返回按钮时，有下面几种形式：</p><ol><li>直接创建一个Button，配置后传入<code>UIBarButtonItem</code>的<code>initWithCustomView</code>方法，之后设为<code>navigationItem.leftBarButtonItem</code>；</li><li>调用一个封装好的<code>attachBackButton</code>方法；</li><li>调用另一个封装好的<code>- (void)setupBackButtonWithText:(NSString *)title color:(UIColor *)color target:(id)target action:(SEL)selector</code>方法，此方法位于一个<code>UIViewController</code>的category中；</li><li>调用再另一个封装好的<code>+ (UIBarButtonItem *)createBackButtonWithText:(NSString*)title color:(UIColor*)color target:(id)target action:(SEL)selector</code>方法，此方法与上一个方法的主要区别是：箭头所用的资源不同，所以前者是黑色箭头，这里是白色箭头。</li></ol><p>而设计团队提出的统一视觉样式方案为：</p><ul><li>二级页面返回采用形如 “&lt; 工作台” 样式；</li><li>其他页面统一为形如 “&lt;” 样式。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>总结一下，对于返回按钮的需求，其实包含了三个维度的定制需求。</p><p>首先是<strong>样式</strong>。</p><p>返回的箭头是一张自定义的图片。</p><p>其次是<strong>文字内容</strong>。</p><p>iOS的系统默认行为是在返回按钮处显示上一个页面的标题，这里显然要通过自定义来取代默认效果。<br>而且注意，这里要支持文字的更新。</p><p>最后是<strong>颜色</strong>。</p><p>这一点的情况比较多，首先它包含两个部分：文字颜色和箭头颜色，这意味着要对自定义图片中箭头的颜色进行更换；另外除了显式地指定颜色外，当<code>NavigationBar</code>的颜色改变时，返回按钮的颜色显然要有对应的改变，即：浅色背景对应深色（黑色）文字，深色背景对应浅色（白色）文字。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来试着一步步达成需求。</p><h3 id="实现自定义箭头"><a href="#实现自定义箭头" class="headerlink" title="实现自定义箭头"></a>实现自定义箭头</h3><p>第一步比较简单，只需调用系统提供的方法即可实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">UIBarButtonItem</span> appearance] setBackButtonBackgroundImage:backButtonImage</span><br><span class="line">                                                forState:<span class="built_in">UIControlStateNormal</span></span><br><span class="line">                                                barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br></pre></td></tr></table></figure><h3 id="隐藏系统默认文字"><a href="#隐藏系统默认文字" class="headerlink" title="隐藏系统默认文字"></a>隐藏系统默认文字</h3><p>实现这个也比较简单，只需新增一个<code>UINavigationItem</code>的category:</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;UINavigationItem+BackButton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UINavigationItem</span>(<span class="title">BackButton</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIBarButtonItem</span> *)backBarButtonItem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">UIBarButtonItem</span> alloc] initWithTitle:<span class="string">@&quot;&quot;</span> style:<span class="built_in">UIBarButtonItemStylePlain</span> target:<span class="literal">nil</span> action:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>截至目前，经过两个简单的步骤，我们已经达到了默认的效果：不经任何配置时，push一个新的页面，会显示一个只有自定义返回箭头，没有文字的返回按钮。</p><p>接下来，我们要针对其他情形进行定制。</p><h3 id="实现自定义文字"><a href="#实现自定义文字" class="headerlink" title="实现自定义文字"></a>实现自定义文字</h3><p>由于<code>UINavigationItem</code>的<code>backBarButtonItem</code>方法已经被我们使用，此处我们用自己生成的<code>UIBarButtonItem</code>设置到<code>UINavigationItem</code>的<code>leftBarButtonItem</code>中，来达到实现自定义文字的目的。</p><p>具体实现的代码特别常规，唯独要说明的是，这里的箭头要根据传进来颜色值变换颜色，来和文字匹配，具体不表。</p><p>方法名依然是<code>- (void)setupBackButtonWithText:(NSString *)title color:(UIColor *)color target:(id)target action:(SEL)selector</code>，后面会用到。</p><h3 id="实现在返回按钮显示上一个页面标题"><a href="#实现在返回按钮显示上一个页面标题" class="headerlink" title="实现在返回按钮显示上一个页面标题"></a>实现在返回按钮显示上一个页面标题</h3><p>为了便于灵活配置，我们新增一个<code>UIViewController</code>的category，并增加一个property来开启此项功能：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span> (<span class="title">NavigationAddition</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> showPreviousViewTitleAsBackButtonTitle;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">NavigationAddition</span>)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * backButtonTitleValue;</span><br><span class="line">-(<span class="keyword">void</span>)setShowPreviousViewTitleAsBackButtonTitle:(<span class="built_in">BOOL</span>)isShowPreviousViewTitleAsBackButtonTitle&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;backButtonTitleValue, @(isShowPreviousViewTitleAsBackButtonTitle), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (isShowPreviousViewTitleAsBackButtonTitle) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *viewControllers = [[<span class="keyword">self</span> navigationController] viewControllers];</span><br><span class="line">        <span class="keyword">if</span> (viewControllers.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">UIViewController</span> *previousViewController = [viewControllers objectAtIndex:([viewControllers indexOfObject:<span class="keyword">self</span>] - <span class="number">1</span>)];</span><br><span class="line">            [<span class="keyword">self</span> setupBackButtonWithText:previousViewController.navigationItem.title color: [<span class="built_in">UIColor</span> blackColor] target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(backButtonPressed:)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    <span class="keyword">id</span> boolObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;backButtonTitleValue);</span><br><span class="line">    <span class="keyword">if</span> (boolObject != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> isShowPreviousViewTitleAsBackButtonTitle = [(<span class="built_in">NSNumber</span> *)boolObject boolValue];</span><br><span class="line">        <span class="keyword">if</span> (isShowPreviousViewTitleAsBackButtonTitle) &#123;</span><br><span class="line">            [<span class="keyword">self</span> setShowPreviousViewTitleAsBackButtonTitle:isShowPreviousViewTitleAsBackButtonTitle];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在property的setter方法中，我们用runtime方法为UIViewController新增了一个属性，增加的原因是，有时我们需要在<code>UIViewController</code>创建时灵活指定此行为，而不是在构造方法中配置。</p><p>这样，在<code>viewWillAppear</code>方法中再去读取这个属性，就能实现灵活配置所需行为的目的。</p><p>在具体的实现中，实际上是取了当前<code>NavigationController</code>的<code>viewControllers</code>属性数组中当前页面的前一个变量，然后读取它的标题。</p><p>然而，以上的实现还是遗留了一些问题。比如，这里对字体的颜色进行了hardcode；另外，当实际代码中在<code>viewWillAppear</code>里又设置了<code>NavigationBar</code>的颜色的时候，两者就可能产生冲突，最终的效果就是可能会看不清按钮。</p><p>所以，我们还需要增加一些逻辑。</p><h3 id="处理颜色"><a href="#处理颜色" class="headerlink" title="处理颜色"></a>处理颜色</h3><p>首先，我们再为<code>UIViewController</code>增添一个属性，来储存自定义的后退按钮颜色。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * backButtonForcedColorValue;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupBackButtonWithText:(<span class="built_in">NSString</span> *)title color:(<span class="built_in">UIColor</span> *)color target:(<span class="keyword">id</span>)target action:(SEL)selector;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (color != <span class="literal">nil</span>) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;backButtonForcedColorValue, color, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = [<span class="keyword">self</span>.class reateBackButtonWithText:title color:color target:target action:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦显式地为后退按钮指定了颜色，这里就会储存下来。</p><p>然后，在设置后退按钮时，我们再把这个属性取出来：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setShowPreviousViewTitleAsBackButtonTitle:(<span class="built_in">BOOL</span>)isShowPreviousViewTitleAsBackButtonTitle&#123;</span><br><span class="line">    ... <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIColor</span> *defaultColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    <span class="keyword">id</span> colorObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;backButtonForcedColorValue);</span><br><span class="line">    <span class="keyword">if</span> (colorObject != <span class="literal">nil</span> &amp;&amp; [colorObject isKindOfClass:[<span class="built_in">UIColor</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        defaultColor = (<span class="built_in">UIColor</span> *)colorObject;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> wbg_setupBackButtonWithText:previousViewController.navigationItem.title color:defaultColor target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(backButtonPressed:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们因为在设置后退按钮时一定要给定一个颜色，但只有少数时候我们是真正要指定一种颜色（比如蓝色），其他时候只是取一个合理的值即可。为了区分显式指定和自动指定两种情况，我们再加一个指示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">UIColor</span> * <span class="built_in">UIColorAutomatic</span>;</span><br></pre></td></tr></table></figure><p>所以最终的方法是这样的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupBackButtonWithText:(<span class="built_in">NSString</span> *)title color:(<span class="built_in">UIColor</span> *)color target:(<span class="keyword">id</span>)target action:(SEL)selector;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (color != <span class="literal">nil</span> &amp;&amp; color != <span class="built_in">UIColorAutomatic</span>) &#123;<span class="comment">// 只在不为自动颜色的时候才设置这里的颜色变量</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;backButtonForcedColorValue, color, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = [<span class="keyword">self</span>.class createBackButtonWithText:title color:[<span class="keyword">self</span> getProperItemColor] target:target action:selector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setShowPreviousViewTitleAsBackButtonTitle:(<span class="built_in">BOOL</span>)isShowPreviousViewTitleAsBackButtonTitle&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;backButtonTitleValue, @(isShowPreviousViewTitleAsBackButtonTitle), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (isShowPreviousViewTitleAsBackButtonTitle) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *viewControllers = [[<span class="keyword">self</span> navigationController] viewControllers];</span><br><span class="line">        <span class="keyword">if</span> (viewControllers.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">UIViewController</span> *previousViewController = [viewControllers objectAtIndex:([viewControllers indexOfObject:<span class="keyword">self</span>] - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span> setupBackButtonWithText:previousViewController.navigationItem.title</span><br><span class="line">                                    color:<span class="built_in">UIColorAutomatic</span> <span class="comment">// 这个方法只负责开启带文字的返回按钮，并不指定颜色，所以传入自动</span></span><br><span class="line">                                   target:<span class="keyword">self</span></span><br><span class="line">                                   action:<span class="keyword">@selector</span>(backButtonPressed:)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在设置<code>NavigationBar</code>颜色的时候，还需要同步更新一下按钮的颜色：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNavigationBarColor:(<span class="built_in">UIColor</span> *)barColor</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置导航条颜色代码</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setNavigationBarItemColor: [<span class="keyword">self</span> getProperItemColor]];    <span class="comment">// 设置NavigationItem的颜色</span></span><br><span class="line">    [<span class="keyword">self</span> setupCustomizedBackButtonIfNeeded];                       <span class="comment">// 如果需要，设置自定义按钮的颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于我们的返回箭头是个自定义的图片，所以在每次颜色改变时，都需要用新的颜色的箭头图片重新设置一次。为此，我们再次新加一个category来达到这个目的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UINavigationBar</span>(<span class="title">CustomColor</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UINavigationBar</span>(<span class="title">CustomColor</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setTintColor:(<span class="built_in">UIColor</span> *)tintColor&#123;</span><br><span class="line">    [<span class="keyword">super</span> setTintColor:tintColor];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *arrowImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;navi_back_icon&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(arrowImage.size, <span class="literal">NO</span>, arrowImage.scale);</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, arrowImage.size.width, arrowImage.size.height);</span><br><span class="line">    [tintColor set];</span><br><span class="line">    <span class="built_in">UIRectFill</span>(rect);</span><br><span class="line">    [arrowImage drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>) blendMode:kCGBlendModeDestinationIn alpha:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *backButtonImage = [newImage resizableImageWithCapInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>)];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIBarButtonItem</span> appearance] setBackButtonBackgroundImage:backButtonImage</span><br><span class="line">                                                      forState:<span class="built_in">UIControlStateNormal</span></span><br><span class="line">                                                    barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>同时，后一个方法其实就是把之前写在<code>viewWillAppear</code>里的代码挪了过来：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setupCustomizedBackButtonIfNeeded&#123;</span><br><span class="line">    <span class="keyword">id</span> boolObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;backButtonTitleValue);</span><br><span class="line">    <span class="keyword">if</span> (boolObject != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> isShowPreviousViewTitleAsBackButtonTitle = [(<span class="built_in">NSNumber</span> *)boolObject boolValue];</span><br><span class="line">        <span class="keyword">if</span> (isShowPreviousViewTitleAsBackButtonTitle) &#123;</span><br><span class="line">            [<span class="keyword">self</span> setShowPreviousViewTitleAsBackButtonTitle:isShowPreviousViewTitleAsBackButtonTitle];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">self</span> setupCustomizedBackButtonIfNeeded];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>getProperItemColor</code>方法集中处理了合理的颜色值：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIColor</span> *)getProperItemColor&#123;</span><br><span class="line">    <span class="built_in">UIColor</span> *defaultColor = <span class="built_in">UIColorAutomatic</span>;</span><br><span class="line">    <span class="keyword">id</span> colorObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;backButtonForcedColorValue);</span><br><span class="line">    <span class="keyword">if</span> (colorObject != <span class="literal">nil</span> &amp;&amp; [colorObject isKindOfClass:[<span class="built_in">UIColor</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果存在钦定的颜色，读取之</span></span><br><span class="line">        defaultColor = (<span class="built_in">UIColor</span> *)colorObject;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 否则，根据导航条背景颜色自动决定颜色</span></span><br><span class="line">        <span class="built_in">CGFloat</span> red, green, blue;</span><br><span class="line">        <span class="built_in">UIColor</span> *color;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UINavigationBar</span> *bar = <span class="keyword">self</span>.navigationController.navigationBar;</span><br><span class="line">        <span class="keyword">if</span> ([bar isKindOfClass:[CRGradientNavigationBar <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            CRGradientNavigationBar *crBar = (CRGradientNavigationBar *)bar;</span><br><span class="line">            <span class="built_in">NSArray</span> *colors = crBar.gradientLayer.colors;</span><br><span class="line">            <span class="keyword">if</span> (colors.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                color = [<span class="built_in">UIColor</span> colorWithCGColor:(__bridge <span class="built_in">CGColorRef</span>)colors[<span class="number">0</span>]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                color = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            color = <span class="keyword">self</span>.navigationController.navigationBar.barTintColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据背景颜色自动决定前景颜色，参考以下网址的算法</span></span><br><span class="line">        <span class="comment">// http://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color</span></span><br><span class="line">        [color getRed:&amp;red green:&amp;green blue:&amp;blue alpha:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">CGFloat</span> luminance = red * <span class="number">0.299</span> + green * <span class="number">0.587</span> + blue * <span class="number">0.114</span>;</span><br><span class="line">        </span><br><span class="line">        defaultColor = luminance &gt; <span class="number">186.0</span> / <span class="number">256.0</span> ? [<span class="built_in">UIColor</span> blackColor] : [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> defaultColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在之前设定过的颜色值，就取出并且返回；否则就根据当前导航条的颜色自动设置为与之反向的颜色。这里参考了一篇Stackoverflow上的<a href="http://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color">讨论帖</a>，直接拿过来了其中使用的算法。</p><p>至此，我们已经达到了预期的目的，而且在调用时也比较方便，自动处理了大部分的情况。比如，如果仅仅想改变返回按钮的颜色，之前可能会创建一个仅指定了颜色的按钮并设置为返回按钮，现在则可以写<code>[self setNavigationBarItemColor:[UIColor someCustomColor]]</code>，虽然代码量与之前一样，但逻辑上比较优雅。</p><p>但是也遇到了两个坑：一个是某个二级页面采用了HTML页面实现，所以特别蛋疼地需要手动通过回调处理一切更新；另一个是某个页面是自己创建了一个<code>UINavigationController</code>然后push进来的（因为该页面需要侧边栏），导致没法拿到上级页面的名称，只能不用<code>showPreviousViewTitleAsBackButtonTitle</code>属性，退而求其次用<code>setupBackButtonWithText</code>方法自行创建一个后退按钮。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><ul><li>默认情况：什么都不用做，自动出现自定义的“&lt;”；</li><li>需要显示上级页面：设置<code>showPreviousViewTitleAsBackButtonTitle</code>属性；</li><li>需要自定义按钮文字：方法1. 调用<code>setupBackButtonWithText</code>方法，用于指定颜色；方法2. 调用’attachBackButtonTitle:’方法，用于自动获取颜色。</li></ul>]]></content>
    
    <summary type="html">
    
      记录了开发一整套返回按钮解决方案的思考过程和实施方案。
    
    </summary>
    
      <category term="Code" scheme="http://zshowing.github.io/categories/Code/"/>
    
    
      <category term="iOS" scheme="http://zshowing.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://zshowing.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>用Core Graphic做个macOS上的屏保</title>
    <link href="http://zshowing.github.io/2016/10/12/Make-a-Matrix-Code-Rain-ScreenSaver-on-macOS/"/>
    <id>http://zshowing.github.io/2016/10/12/Make-a-Matrix-Code-Rain-ScreenSaver-on-macOS/</id>
    <published>2016-10-12T11:28:54.000Z</published>
    <updated>2016-10-12T15:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写<a href="https://zshowing.github.io/2016/10/09/Project-Matrix-Code-Rain/">上一篇</a>的同时我就在考虑，既然都做到了这个地步，能不能干脆移植到macOS上，做个屏保呢？</p><p>我决定试一试。</p><h2 id="确定方案"><a href="#确定方案" class="headerlink" title="确定方案"></a>确定方案</h2><p>在真正开始做之前我考察了一下Metal和OpenGL，觉得学习曲线相对“移植”这个任务来讲有点过于陡峭。由于之前从没正经做过macOS上的项目，还是觉得这次步子先迈小一点，大方向上继续沿用之前的Core Graphic方案。</p><p>由于上一篇的工程是基于Swift 3的，而如果你在XCode中创建屏幕保护的模板工程的话，会发现它并没有给你选择语言的余地，直接就给了你一个Objective-C的工程。由于程序员天生有着<del>爱偷懒</del>不喜欢重复造轮子的优良品性，我的第一反应是，能不能我自己手动建个Swift的工程？</p><p>但是我实验的结果是似乎目前存在兼容性问题，编译出的屏保总是莫名其妙crash。有人也遇到了同样的问题：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8prz5wucij21cc11w7jv.jpg" alt=""></p><p>无奈，我还是及时止损，老老实实用Objective-C重写了遍主要的逻辑。</p><p>仅就这个项目中用到的东西而言，Cocoa和Cocoa Touch的差别比预想中的还要小，夸张点说，基本上只是把“UI”打头的东西换成“NS”就搞定了（比如<code>UIFont</code>和<code>NSFont</code>，<code>UIScreen</code>和<code>NSScreen</code>等）。</p><p>顺便一题，默认的屏保模板是不能debug的，你需要自己手动添加一个target，然后在该target的<code>AppDelegate</code>里面自己把屏保的view加进来：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_rainView = [[CodeRainView alloc] initWithFrame:<span class="built_in">CGRectZero</span> isPreview:<span class="literal">NO</span>];</span><br><span class="line">_rainView.frame = _window.contentView.bounds;</span><br><span class="line">[_window.contentView addSubview:_rainView];</span><br></pre></td></tr></table></figure><p>但是当我费半天劲翻译完程序，真正运行起来后却发现，这货在堂堂电脑上居然跑得比在手机上更慢！</p><p>想了一下，大概的原因可能是，由于电脑的屏幕大，能同时容纳的track就更多，因此同时要刷新的track数量在运行开始后就会很快上升到可观的程度。</p><p>要是像上一篇那样，改成后台渲染呢？</p><p>试了一下，效果也不是很好。</p><p>于是，我开始琢磨换一种实现方式。</p><h2 id="CALayer黄金搭档"><a href="#CALayer黄金搭档" class="headerlink" title="CALayer黄金搭档"></a>CALayer黄金搭档</h2><p>考虑到这个效果的本质其实是“照亮”已经排布好的矩阵，我们可以尝试不去自己绘制字符，而是也先排布好字符，然后照亮它！</p><p>于是自然就想到CALayer家族中的两位成员和一个小弟：<code>CATextLayer</code>、<code>CAGradientLayer</code>和<code>mask</code>属性。</p><p>顾名思义，他们一个用来显示字符，一个用来显示渐变，一个用来产生遮罩。</p><p>无图无真相，大概是下面这个意思：</p><h3 id="产生字符（CATextLayer）"><a href="#产生字符（CATextLayer）" class="headerlink" title="产生字符（CATextLayer）"></a>产生字符（CATextLayer）</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *characters = [[JSMatrixDataSource sharedDataSource] characters][track.trackNum];</span><br><span class="line"><span class="built_in">NSString</span> *trackString = [characters componentsJoinedByString:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">attrString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:trackString</span><br><span class="line">                                                    attributes: [JSMatrixDataSource getStringAttrs]];</span><br><span class="line"><span class="keyword">self</span>.string = attrString;</span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8pt5xzfm8j21kw162npd.jpg" alt=""></p><h3 id="产生遮罩-CAGradientLayer"><a href="#产生遮罩-CAGradientLayer" class="headerlink" title="产生遮罩(CAGradientLayer)"></a>产生遮罩(CAGradientLayer)</h3><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f8pt72dip5j21kw162kjl.jpg" alt=""><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.gradientLayer = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line"><span class="keyword">self</span>.gradientLayer.colors = @[(__bridge <span class="keyword">id</span>)[<span class="built_in">NSColor</span> whiteColor].CGColor, (__bridge <span class="keyword">id</span>)[[<span class="built_in">NSColor</span> whiteColor] colorWithAlphaComponent:<span class="number">0</span>].CGColor];</span><br><span class="line"><span class="keyword">self</span>.gradientLayer.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">self</span>.gradientLayer.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *newActions = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithObjectsAndKeys:[<span class="built_in">NSNull</span> null], <span class="string">@&quot;onOrderIn&quot;</span>,</span><br><span class="line">                                   [<span class="built_in">NSNull</span> null], <span class="string">@&quot;onOrderOut&quot;</span>,</span><br><span class="line">                                   [<span class="built_in">NSNull</span> null], <span class="string">@&quot;sublayers&quot;</span>,</span><br><span class="line">                                   [<span class="built_in">NSNull</span> null], <span class="string">@&quot;contents&quot;</span>,</span><br><span class="line">                                   [<span class="built_in">NSNull</span> null], <span class="string">@&quot;bounds&quot;</span>,</span><br><span class="line">                                   [<span class="built_in">NSNull</span> null], <span class="string">@&quot;position&quot;</span>,</span><br><span class="line">                                   <span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.gradientLayer.actions = newActions;</span><br></pre></td></tr></table></figure><br>中间给actions设置的一段是为了禁用CALayer的隐式动画，因为我们此处需要的就是一跳一跳的效果。</p><h3 id="设置蒙版（mask）"><a href="#设置蒙版（mask）" class="headerlink" title="设置蒙版（mask）"></a>设置蒙版（mask）</h3><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f8pt8rjb9yj21kw162qdn.jpg" alt=""><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.mask = <span class="keyword">self</span>.gradientLayer;</span><br></pre></td></tr></table></figure></p><p>1 + 2 = 3. Simple like that.</p><p>PS. 有一个小坑就是CATextLayer的刷新并不及时，因此需要我们手动清空它的内容并标记为需要刷新：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.contents = <span class="literal">nil</span>;        <span class="comment">// Force the layer to clear its content</span></span><br><span class="line">[<span class="keyword">self</span> setNeedsDisplay];     <span class="comment">// Then mark the layer needs redraw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.string = ...           <span class="comment">// Set the new content</span></span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>然后我用Instrument进行了一下测试，惊讶地发现在一个简单的取屏幕最大行数的方法上居然耗费了主线程10%的时间：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f8ptg868ejj21080bu0z6.jpg" alt=""></p><p>为了解决这个问题，我把计算结果缓存了下来，这样以后每次取用时只需读取之前的计算结果：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UInt</span>)maxNum&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">UInt</span> num;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        num = ceilf([<span class="built_in">NSScreen</span> mainScreen].frame.size.height / [JSMatrixDataSource capHeight]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而在Swift上，只需把变量声明为<code>static</code>即可达到上述效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> maxNum: <span class="type">Int</span> <span class="operator">=</span> <span class="type">Int</span>(ceilf(<span class="type">Float</span>(<span class="type">UIScreen</span>.main.bounds.height <span class="operator">/</span> <span class="type">JSMatrixCodeRainView</span>.characterSize.height)))</span><br></pre></td></tr></table></figure><p>（我真的不是在黑OC，没有任何这个意思。）</p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>大概是酱紫：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f8pvcic6h7j21kw16owmx.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8puwcp8rcg20b4069qv6.gif" alt=""></p><p>其实在运行时还是会注意到有些不自然，但更加出色的表现还是得祭出OpenGL或者Metal来做。这就留给以后了。包括还可以设置<code>zPosition</code>实现一些纵深感的变换效果，由于这些先天不足也懒得做了。</p><p>另外我其实完全抛弃了系统默认的屏保实现机制（在<code>animateOneFrame</code>方法中写动画逻辑来前进一帧），也算是个非主流的屏保……</p><p>代码已经共享到了GitHub：<br><a href="https://github.com/zshowing/JSMatrixCodeRainScreenSaver">https://github.com/zshowing/JSMatrixCodeRainScreenSaver</a></p><p>或者直接下载：<br><a href="https://pan.baidu.com/s/1eRJE2P0">https://pan.baidu.com/s/1eRJE2P0</a></p>]]></content>
    
    <summary type="html">
    
      把上一篇里面的Code Rain移植到了macOS，做了个屏保。
    
    </summary>
    
      <category term="Code" scheme="http://zshowing.github.io/categories/Code/"/>
    
    
      <category term="Objective-C" scheme="http://zshowing.github.io/tags/Objective-C/"/>
    
      <category term="Core Graphic" scheme="http://zshowing.github.io/tags/Core-Graphic/"/>
    
      <category term="macOS" scheme="http://zshowing.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>第一个练手作品：Matrix Code Rain&lt;br&gt;及对Core Graphics绘制的优化</title>
    <link href="http://zshowing.github.io/2016/10/09/Project-Matrix-Code-Rain/"/>
    <id>http://zshowing.github.io/2016/10/09/Project-Matrix-Code-Rain/</id>
    <published>2016-10-08T17:33:22.000Z</published>
    <updated>2016-10-09T10:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>书接上文，上回书说到我意识到自己在专业领域有欠缺，于是正在大量阅读Blog。在9月25号看到Kevin Chou的<a href="http://blog.zhowkev.in/2013/11/11/pnchart-hit-no-1-objective-c-repos-in-github/">这篇</a>介绍他开源的组件库<a href="https://github.com/kevinzhow/PNChart">PNChart</a>受到欢迎的文章时，我突然想到：对啊，这是个把自己喜好与技术积累结合起来的好途径！之前总觉得往开源社区贡献代码需要超强的底层代码功力，又不想仿写已有的组件重复造轮子，这时我才刚刚意识到，上层的UI层面同样需要优秀的贡献——某种程度上讲更加稀缺，毕竟同时对设计和代码都有研究的程序员比较少。</p><p>恰好，一个做前端的朋友Fanta发来了一份他业余时间用HTML+JS写着玩做的《黑客帝国》代码雨效果的demo：<br><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8m0vyssmbg20b406m7wh.gif" alt=""></p><p>我觉得这个还挺有意思，搜了一下GitHub上还没有做过的，于是便开始了编码工作。</p><h2 id="架构及轨迹生成"><a href="#架构及轨迹生成" class="headerlink" title="架构及轨迹生成"></a>架构及轨迹生成</h2><p>这是一个很简单的小组件，所以基本架构也很简单：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f8m1v5se6mj20y80jyt9v.jpg" alt=""></p><p>我们约定将每一条下落的轨迹都称为一个<code>Track</code>，由一个<code>Generator</code>实例专门来生成，每隔指定的时间（显然，随机亦可）就新生成一条，加到<code>DataSource</code>中，并创建其对应的<code>CALayer</code>子类<code>CodeRainLayer</code>加到最底层的<code>UIView</code>上。</p><h2 id="下落及轨迹清理"><a href="#下落及轨迹清理" class="headerlink" title="下落及轨迹清理"></a>下落及轨迹清理</h2><p>如何产生动画呢？最开始自然想到用<code>CAAnimation</code>来做。<br>因为代码太简单，就不在这里写了。<br>但是写完个大概之后，运行起来却发现不对劲：总感觉没有电影里面酷。</p><p>问题出在哪里呢？我又从移动硬盘里翻出了那三部曲仔细地研究了一下，经过一帧一帧地探究，我找到了原因：<br>电影里面的代码并不是在“下落”，如果你盯着一个字母看，会发现它根本就没移动过位置（除去镜头本身的移动）。换句话说，整个空间是一个已经排列好的字母矩阵，而我们看到的表象是<strong>一阵脉冲流过</strong>而已。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f8m3n5c8j6g20b404vx6p.gif" alt=""></p><p>所以最后改成的方案是由每个<code>Track</code>实例自带的<code>Timer</code>负责驱动控制自身的下落（为表述方便我们依然沿用这个词），当需要刷新时，通知其对应的<code>CodeRainLayer</code>实例（<code>-setNeedsDisplay</code>）进行重绘。至于如何重绘，由每个<code>CodeRainLayer</code>自行负责。</p><p>而当整条轨迹掉出屏幕的时候，<code>Track</code>会检测出边界条件，然后把对应的<code>CALayer</code>执行<code>removeFromSuperlayer</code>，最后把自身从<code>DataSource</code>中清除。</p><h2 id="阶段性成果"><a href="#阶段性成果" class="headerlink" title="阶段性成果"></a>阶段性成果</h2><p>OK, so far so good. 我们成功实现了整个的动画效果，看起来也确实蛮酷的：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8hmevmxy9g20a00hsb29.gif" alt=""></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在把它传到GitHub之前，还需要进行一些封装。这里主要有两方面的工作，一个是增加控制关键字来限制外界能接触到的内部类和方法，另一个是将可调节的参数向外界暴露出来。</p><h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><p>在Swift 3中特地新加了<code>fileprivate</code>这个访问权限，正好在这里可以用到。我们把不希望暴露给外界的类都加上这个限定关键字。</p><p>顺便，Swift 3中的访问权限依次是：</p><blockquote><p>open，public，internal，fileprivate，private.</p></blockquote><h3 id="Configurable-Parameters"><a href="#Configurable-Parameters" class="headerlink" title="Configurable Parameters"></a>Configurable Parameters</h3><p>在之前，组件中用到的所有参数都定义在了一个<code>struct</code>里：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">JSMatrixConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxGlowLength: <span class="type">Int</span> <span class="operator">=</span> <span class="number">3</span> <span class="comment">// Characters</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> minTrackLength: <span class="type">Int</span> <span class="operator">=</span> <span class="number">8</span> <span class="comment">// Characters</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxTrackLength: <span class="type">Int</span> <span class="operator">=</span> <span class="number">40</span> <span class="comment">// Characters</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> charactersSpacing: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0.0</span> <span class="comment">// pixel</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> characterChangeRate <span class="operator">=</span> <span class="number">0.9</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> firstDropShowTime <span class="operator">=</span> <span class="number">2.0</span> <span class="comment">// Time between the First drop and the later</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Configurable</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> speed: <span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">0.15</span> <span class="comment">// Seconds that new character pop up</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> newTrackComingLap: <span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">0.4</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> tracksSpacing: <span class="type">Int</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了暴露其中的一些参数，我们在<code>CodeRainView</code>那里增加几个变量：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> trackSpacing: <span class="type">Int</span></span><br><span class="line"><span class="keyword">var</span> newTrackComingLap: <span class="type">CGFloat</span></span><br><span class="line"><span class="keyword">var</span> speed: <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure></p><p>那么如果用户不设置的时候呢？我们应该用回默认值。比如这样：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> speed: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="type">CGFloat</span>(<span class="type">JSMatrixConstants</span>.speed)&#123;</span><br><span class="line">    <span class="keyword">didSet</span>&#123;</span><br><span class="line">        datasource.speed <span class="operator">=</span> <span class="type">TimeInterval</span>(speed)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newTrackComingLap: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="type">CGFloat</span>(<span class="type">JSMatrixConstants</span>.newTrackComingLap)&#123;</span><br><span class="line">    <span class="keyword">didSet</span>&#123;</span><br><span class="line">        datasource.newTrackComingLap <span class="operator">=</span> <span class="type">TimeInterval</span>(newTrackComingLap)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> trackSpacing: <span class="type">Int</span> <span class="operator">=</span> <span class="type">JSMatrixConstants</span>.tracksSpacing&#123;</span><br><span class="line">    <span class="keyword">didSet</span>&#123;</span><br><span class="line">        datasource.trackSpacing <span class="operator">=</span> trackSpacing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而一个2016年的UI组件应当是Interface Builder-Friendly的——尤其是，要做到这点只需举手之劳：将上面的参数声明为<code>@IBInspectable</code>。</p><p>最后在IB中看到的效果是：<br><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f8hq5majxfj20du050jrx.jpg" alt=""></p><h2 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h2><p>在我的iPhone6s上测试时，整个组件的表现没什么大问题；但在比较老的iPhone5s上测试时，就有点吃力了。虽然画面依然比较流畅，在CPU监测中能明显看出占用：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8m6n7zdqcj21cu112dn7.jpg" alt=""></p><p>而在我后面想结合一些<code>CoreMotion</code>的回调实现<code>视角缩放</code>效果时，在5s上的画面终于卡了起来。</p><p>之所以会卡很容易理解，整个组件在主线程中进行了大量的绘制工作，搁你你也卡。</p><p>在我搜索相关信息的时候，偶然看到一篇叫<a href="http://vizlabxt.github.io/blog/2013/07/12/custom-drawing/">《一些提高UI绘制性能的技巧》</a>的文章中写道：</p><blockquote><p>绘制UIView最快的方法就是把它当成imageview，我们把需要用Core Graphic绘制的代码放到另一个线程中去绘制，生成image后直接赋值给view，达到异步绘制的目的。</p></blockquote><p>我试了一下，差不多是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> track <span class="operator">=</span> <span class="keyword">self</span>.track</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="keyword">let</span> size <span class="operator">=</span> <span class="keyword">self</span>.bounds.size</span><br><span class="line">    <span class="type">UIGraphicsBeginImageContext</span>(size)</span><br><span class="line">    context.saveGState()</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span> <span class="comment">// Calculate positions, etc.</span></span><br><span class="line"></span><br><span class="line">    context.restoreGState()</span><br><span class="line">    <span class="keyword">self</span>.render(in: context)</span><br><span class="line">    <span class="keyword">let</span> resultImage <span class="operator">=</span> <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> resultImage&#123;</span><br><span class="line">            <span class="keyword">self</span>.contents <span class="operator">=</span> image.cgImage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样做有问题：在每一次更新的时候，这个Layer需要在空白的背景下进行绘制，而直接调用<code>self.render(in: context)</code>方法，绘制的内容会叠加在当前显示的内容之上，出来的效果是不可用的。（截图过于残暴，从略）</p><p>那么怎么解决这个问题呢？一个直接的想法是，如果能在一个新的context上绘制就好了。</p><p>带着这个目标去搜索，在<a href="http://www.b2cloud.com.au/tutorial/cgcontext-drawing-in-a-thread/">这个文章</a>里面介绍了创建context的方法，于是上面的代码变成了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> track <span class="operator">=</span> <span class="keyword">self</span>.track</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="keyword">let</span> size <span class="operator">=</span> <span class="keyword">self</span>.bounds.size</span><br><span class="line">    <span class="type">UIGraphicsBeginImageContext</span>(size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Create drawing context */</span></span><br><span class="line">    <span class="keyword">let</span> colorSpace <span class="operator">=</span> <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">    <span class="keyword">let</span> createdContext <span class="operator">=</span> <span class="type">CGContext</span>(data: <span class="literal">nil</span>, width: <span class="type">Int</span>(size.width), height: <span class="type">Int</span>(size.height), bitsPerComponent: <span class="number">8</span>, bytesPerRow: <span class="number">0</span>, space: colorSpace, bitmapInfo: <span class="type">CGImageAlphaInfo</span>.premultipliedLast.rawValue)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> context <span class="operator">=</span> createdContext&#123;</span><br><span class="line">        context.saveGState()</span><br><span class="line">        </span><br><span class="line">        <span class="operator">...</span> <span class="comment">// calc positions, etc.</span></span><br><span class="line">        </span><br><span class="line">        context.restoreGState()</span><br><span class="line">        <span class="keyword">self</span>.render(in: context)</span><br><span class="line">        <span class="keyword">let</span> resultImage <span class="operator">=</span> <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> resultImage&#123;</span><br><span class="line">                <span class="keyword">self</span>.contents <span class="operator">=</span> image.cgImage</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h2><p>搞定了这些之后兴冲冲地在5s上跑了一下，发现除了线程多了一些之外，差别几乎不可见：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f8m6mvur82j21cm10wwmk.jpg" alt=""></p><p>细想一下也可以理解，我们并没有减少任何绘制的工作量，只不过是把它们移到了后台线程而已。</p><p>那么接下来的问题是，在为主线程减了这么多负之后，程序的响应性能有提高吗？因为要是再没什么变化的话，我要为前面这些花出的时间哭几秒。</p><p>接下来我搜到了一篇讲述如何测量程序响应性的<a href="https://medium.com/@mandrigin/ios-app-performance-instruments-beyond-48fe7b7cdf2#.i64rhcfy0">文章</a>，还附了源码的截图，非常良心。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">PingThread</span>: <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pingTaskIsRunning <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span><span class="keyword">self</span>.isCancelled&#123;</span><br><span class="line">            pingTaskIsRunning <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="keyword">self</span>.pingTaskIsRunning <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span><span class="operator">/</span><span class="number">30.0</span>)</span><br><span class="line">            <span class="keyword">if</span> pingTaskIsRunning &#123;</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">&quot;Delayed!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">_</span> <span class="operator">=</span> semaphore.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是，每隔一定的时间就在主线程给该线程的信号量发消息，要是主线程因为卡顿耽搁了，该线程就会输出警告信息。</p><p>我把时间设为1/30秒，因为这是一个流畅的动画所应当达到的帧率。</p><p>这下终于有了喜人的对比结果：</p><p>之前：<br><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f8m6w0biu1j20wq1321kx.jpg" alt=""></p><p>之后：<br><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f8m6wnhmlfj20y40lowj8.jpg" alt=""></p><p>直到启动20多秒后收到内存警告，都没有一次卡顿出现！</p><p>虽然我不是一个使用meme表情控，但看国外的blog看多了之后，总觉得在这种情况下需要出现一个表情……</p><p>就是下面这个：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79gw1f8m74cap54j20b40b4aal.jpg" alt=""></p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>整个项目已经传到了GitHub上：<br><a href="https://github.com/zshowing/JSMatrixCodeRainView">https://github.com/zshowing/JSMatrixCodeRainView</a></p><p>通过这个项目，我学到的东西包括：</p><ul><li>Core Graphic的一些深入内容</li><li>一些之前用不到的封装策略</li><li>一个优化绘制性能的方法</li><li>一个测量程序响应性能的方法</li></ul><p>接下来又想到一个比较有趣的项目，不知道什么时候能填坑。</p><p>感谢观赏。</p>]]></content>
    
    <summary type="html">
    
      记录了实现电影《黑客帝国》中代码雨效果的过程，以及随后对Core Graphics绘制的优化。
    
    </summary>
    
      <category term="Code" scheme="http://zshowing.github.io/categories/Code/"/>
    
    
      <category term="iOS" scheme="http://zshowing.github.io/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://zshowing.github.io/tags/Core-Graphics/"/>
    
      <category term="优化" scheme="http://zshowing.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="Swift" scheme="http://zshowing.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Advanced Self-Examination and Status Analyze II</title>
    <link href="http://zshowing.github.io/2016/09/22/Advanced-Self-Examination-and-Status-Analyze-II/"/>
    <id>http://zshowing.github.io/2016/09/22/Advanced-Self-Examination-and-Status-Analyze-II/</id>
    <published>2016-09-22T07:01:52.000Z</published>
    <updated>2016-09-25T09:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>是的，本课程在<a href="/2016/08/06/Advanced-Self-Examination-and-Status-Analyze/">第一级</a>落幕仅仅一个月之后，就迎来了第二级。</p><p>上一篇的视角比较高，是从迄今为止的所有人生中总结的经验，而这一篇的视角则聚焦在今年3月辞职后到现在的半年间，准备记录一些尝试和相关的思考。</p><p>这几个月的生活，可以分成几个阶段：</p><h2 id="关键词：休整-（2月-4月）"><a href="#关键词：休整-（2月-4月）" class="headerlink" title="关键词：休整 （2月 - 4月）"></a>关键词：休整 （2月 - 4月）</h2><p>别人都是Gap year，我这算是过了个Gap quarter.</p><p>在4月底的时候，我在日记里做了个阶段性总结，作为进入下一阶段前的终章：</p><table><thead><tr><th>日期</th><th>事件</th></tr></thead><tbody><tr><td>2.4 - 2.8</td><td>发烧养病</td></tr><tr><td>2.9 - 2.21</td><td>春节各种串亲戚相关事务 &amp; The Last of Us &amp; 整理高中毕业就没管过的各种杂物</td></tr><tr><td>2.22 - 2.24</td><td>为朋友<a href="/2016/02/24/visual-design-for-Simptrue/">设计公司Logo</a>，去同学的公司面试</td></tr><tr><td>2.25 - 2.29</td><td>继续整理杂志和杂物，前同事的公司电话面试，文明5</td></tr><tr><td>3.1 - 3.7</td><td>准备签证资料，递签，继续整理屋子和书柜</td></tr><tr><td>3.8 - 3.28</td><td>写朋友介绍的私活项目，规划英国之行的路线、联系airbnb等，豆瓣面试</td></tr><tr><td>3.29 - 4.17</td><td>英国</td></tr><tr><td>4.18 - 4.26</td><td>调时差，整理行李，完成The Last of Us</td></tr></tbody></table><p><br></p><p>看完了六部剧（Mad Men S7, A to Z S1, 高堡奇人S1，Sherlock S2，Fargo S1 &amp; S2）；<br>看掉了三部电影（The Intern, Zootopia, 怪物之子）；<br>看完了一部纪录片（The Making of The Last of Us）；<br>打穿了一部游戏（The Last of Us）；<br>看完了两本书（The Art of The Last of Us, 配色设计原理）；<br>在现场看了场演唱会（BabyMetal!!）；<br>去了一个之前没去过的国家（U.K）。</p><p>以上写于4月26日。</p><p>接下来的事情：</p><ul><li>设计图标；</li><li>按招聘要求弥补一些知识漏洞；</li><li>个人网站计划；</li><li>了解出国的可能性；</li><li>个人iOS项目；</li><li>读书。</li></ul><p>以上写于4月28日。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f82dri8yrlj21kw16ox4p.jpg" alt=""></p><p>这阶段没太多好讲的，除了把心心念念的游戏打完，去英国当了次BM教徒之外，就算是彻底和之前的日子做了个了结吧——我的房间里从高中毕业后就一直堆在那里没心气儿整理的几个大箱子终于被一点点清空了，没有个整块的时间（花了两周多！）真是不敢启动这么大的工程。</p><h2 id="关键词：设计-（5月-6月）"><a href="#关键词：设计-（5月-6月）" class="headerlink" title="关键词：设计 （5月 - 6月）"></a>关键词：设计 （5月 - 6月）</h2><p>上面的工作列表中排在第一位的是设计图标，这是受到一个正在创业的朋友的委托——某种程度上讲是照顾，因为她知道我对这一方面有兴趣。另外，前面提到的设计公司Logo也是给她们做的方案（见<a href="/2016/02/24/visual-design-for-Simptrue/">《Simptrue企业VI视觉设计策划案》</a>），只不过最终在竞标中败给了专业设计师。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f82a9oqt7rj21kw11xatq.jpg" alt=""></p><p>等这个设计告一段落之后，我的另一个夙愿又浮上心头，就是上面列表中的第三点。一直以来，我都有个自己设计一个属于自己的个人主页的想法，这次终于有整块的时间来搞一搞了。从搜集相关作品，到出设计图，到做资源，到写代码，差不多弄了一个月。（虽然，中间又夹杂了两局文明5和一部动漫 =.=）<br>（设计过程详见另一篇<a href="https://www.douban.com/note/566496095/）">https://www.douban.com/note/566496095/）</a></p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f82a4p2p6ij21kw0zkjz8.jpg" alt=""></p><p>最后的结论是，在这方面要想真正做点东西，果然还是需要相当长的储备才行。至于成为理想中的自由职业者，更是差得太远。年初时曾经对离职后的生活充满憧憬（<a href="/2016/01/01/Summary-of-2015/">《Bye, 2015》</a>），到这时已经觉察出有点图森破乃衣服了。</p><h2 id="关键词：单词-（7月）"><a href="#关键词：单词-（7月）" class="headerlink" title="关键词：单词 （7月）"></a>关键词：单词 （7月）</h2><p>于是我想到了之前一直没认真考虑过的事情：留学——既然搞设计没有那么容易，我就去真刀真枪学一年。这也是上面的列表中紧随个人网站，排名倒数第三的议题。</p><p>所以，一整个7月份，我都在一边看《废柴联盟》，一边背单词。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82aqu1wbej21kw16mdva.jpg" alt=""></p><p>差不多背了两三周之后，我开始跟进阅读。而这一阅读，发现了问题。</p><p>正像我之前那篇文章所写：</p><blockquote><p>阅读速度非常差劲，建议15-17分钟完成的阅读，计时完成时间普遍在30分钟以上；<br>前几天试着看了一下&lt;Lord of the Flies&gt;，只读了4页，在Evernote里作了整整一页的笔记，花了一个小时<br>…</p></blockquote><p>这不是在短时间内能突击的能力——就算是，再加上口语和作品集这两个坑，考虑到申请的deadline和目前的存款，这样做下去显然没有意义。</p><p>于是8月初的时候，我写了上面提到的<a href="/2016/08/06/Advanced-Self-Examination-and-Status-Analyze/">《Advanced Self-Examination and Status Analyze》</a>这篇文章，标志着正式转向下一个阶段。</p><h2 id="关键词：学习-（8月-9月）"><a href="#关键词：学习-（8月-9月）" class="headerlink" title="关键词：学习 （8月 - 9月）"></a>关键词：学习 （8月 - 9月）</h2><p>这个关键词对应的是上面工作列表中的第二项“按招聘要求弥补一些知识漏洞”和最后一项“读书”。至此，4月份列的任务，已经全部进入生活轨道。</p><p>这几个月断续或主动或被动地参加了几场面试，我更进一步地意识到，当初自己所怀的那些信心都是虚假的信心（一月份一个猎头说我这种经历在市场上比较抢手；二月份应邀去同学公司面试顺利拿到offer等），而三月份在豆瓣的面试才是实际情况。</p><p>而在网上补漏洞的时候浏览了很多blog，更是发现自己的差距。</p><p>我是真的念了两句诗：悟已往之不谏，知来者之可追。</p><p>还能怎么办呢，只能一点点追赶。</p><p>8月13日，补完《TCP/IP详解 卷一》；<br>8月17日，补完《Database Systems》；<br>8月24日，补完《深入理解计算机系统》；<br>9月2日，大致补完《算法（第四版）》（这本书其实从离职前就开始慢慢看了）……</p><p>然后开始继续补这几年间业界的blog，并且萌生了“我在上个项目里明明也有可以分享的地方啊”的想法——这才诞生了现在这个博客。</p><p>之前几年，在技术上所有的着眼点都是解决问题，虽然也想过写点什么，但总觉得没得写。</p><p>在阅读了大量博文后我才明白，这种想法只是因为缺少一种心态和思路而已。</p><p>——一种经营自己的心态，和一种刨根问底的思路。</p><p>对前者的说明，最好的例子是唐巧的<a href="http://blog.devtang.com/2014/01/08/why-we-need-write/">《作为码农，我们为什么要写作》</a>一文中提到的“影响力”一节：</p><blockquote><p>当你持续的写作，坚持一年以上，你就会慢慢收获影响力。这个时候，你也会收到技术大会的分享邀请，出版社的约稿邀请，著名互联网公司的工作邀请，甚至是创业项目的合伙人邀请。你相比那些不分享的人，获得了更多的机会。</p></blockquote><p>确实如此，你不发声，没人认识你。</p><p>因此有时想想我会感谢之前拒掉我的公司，正是这几个月间的曲折让我领悟到了这些。如果当时我如愿进了那家公司，现在怕是还自我感觉良好地装逼呢吧。</p><h2 id="关键词：工作-（现在）"><a href="#关键词：工作-（现在）" class="headerlink" title="关键词：工作 （现在）"></a>关键词：工作 （现在）</h2><p>自我提升的感觉固然好，但时间久了也会有些缺乏方向。</p><p>更现实的问题是，没有工作会面临经济收入和人际交往的双重停摆。这不是件好的事情。</p><p>所以，我建立起了这个博客，花了大概五天时间写了上篇博文<a href="/2016/09/21/the-rewrite-of-ChinaMetro-V4-0/">《地铁通4.0版iOS客户端重写中的一些经验》</a>（我几乎是按写毕业论文的规格来写的），以准备面试。</p><p>所以……加油吧，不管是大厂，还是创业公司，只要是能提升自己的地方，都是好的。不用怕丢脸，也不用怕挫败，what doesn’t kill you will make you stronger.</p><p>May the force be with you.</p><p><br><br><br></p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f82dg02wcvj20ff0p1qad.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      工作五年后的Gap quarter，和跳出舒适区后的思考。
    
    </summary>
    
      <category term="Life" scheme="http://zshowing.github.io/categories/Life/"/>
    
    
      <category term="Career" scheme="http://zshowing.github.io/tags/Career/"/>
    
      <category term="Life" scheme="http://zshowing.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>地铁通4.0版iOS客户端重写中的一些经验</title>
    <link href="http://zshowing.github.io/2016/09/21/the-rewrite-of-ChinaMetro-V4-0/"/>
    <id>http://zshowing.github.io/2016/09/21/the-rewrite-of-ChinaMetro-V4-0/</id>
    <published>2016-09-21T03:30:22.000Z</published>
    <updated>2016-10-18T04:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><a href="https://itunes.apple.com/cn/app/tie-tong-touchchina-quan-guo/id530096786?mt=8">地铁通</a>是一款覆盖了国内全部和国外部分已开通地铁城市的导航类应用，入选了苹果的AppStore精华，至今仍在地铁关键字搜索排名第一。迄今为止（注：2016年2月）iOS版的总下载数为237万，苹果后台显示的日活跃用户约为5万。</p><p>我是从2013年起接手的这个应用，在那之前是一个在中国定居的法国同事<a href="https://www.linkedin.com/in/kevintingwingyuen">Kevin</a>搭起的总体架构，在SVN显示的第一次提交是2012年6月14日。在这漫长的时间里，由于可以想象的项目进度和迭代压力，重写架构这种费力不讨好的事儿自然一直没法安排。</p><p>事实上，小规模的重构（即，单个页面规模）一直在进行，在2014年8月的一个版本我由于花了很大力气重构得比较狠，还恶搞苹果的Jony Ive，用他的口吻做了几页宣传PPT：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wyleayk0j20z00iwjsq.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wylci9t9j20z00iwdih.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wyldc3a8j20z00jatci.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wylcuyzjj20z00jgq63.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7wylcmw7pj20z00j2juh.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wylbywtgj20z00jg0t1.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wylby2xej20z00iwt8s.jpg" alt=""></p><p>（此处有掌声）  </p><p>尽管如此，更大规模，或者说，更底层的架构级重构还是一直没时间进行。由于横跨多个业务场景，这种级别的重构工作势必占用几周的完整时间，还要进行彻底的测试。作为一家创业公司是承受不起的，只能想想。</p><p>正如Pinterest在介绍他们重写程序架构的blog（<a href="https://engineering.pinterest.com/blog/re-architecting-pinterests-ios-app">《Re-architecting Pinterest’s iOS app》</a>）里面写的：</p><blockquote><p>A small team of Pinterest iOS engineers was recently given <strong>the opportunity every engineer dreams of</strong> - completely rethinking and rebuilding our app.</p></blockquote><p>直到我决定要离职，出于一种代码洁癖和少许的社会责任感（我觉得在我之后怕是没人能做得起这种量级的代码调整了，难道就把这一坨四年历史的充满补丁的垃圾留给200多万用户吗？），外加一股想要自我救赎的冲动（我认为，能自己把自己的烂代码改掉是一种自我救赎），我向Boss提出了重构申请，作为离职前的最后一个项目。</p><p>地铁通4.0项目就这么立项了。</p><h2 id="程序概貌"><a href="#程序概貌" class="headerlink" title="程序概貌"></a>程序概貌</h2><p>在深入讲解之前，我先整体介绍一下地铁通这款app的大致组成。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7xjpm7k50j20ku112n4x.jpg" width="50%"/></p><p>如上面的主界面截图，地铁通的主要功能就是显示地铁图和查询两个站点间的最佳换乘路线，大概的模块划分如下：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7xleabzvzj21h016eten.jpg" alt=""></p><h2 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h2><p>接下来，让我们分析一下在3.x版本的地铁通里面都存在哪些需要改进的问题。</p><h3 id="ViewController职责过多"><a href="#ViewController职责过多" class="headerlink" title="ViewController职责过多"></a>ViewController职责过多</h3><p>这可以说是任何一个未精心设计过架构的iOS App必然会导致的结果，在苹果的MVC架构中，ViewController这一级是最容易膨胀的，业界风起云涌的诸如MVVM等架构正是为了解决这种问题。</p><p>具体到项目中，比如在展示搜索结果的<code>线路结果页</code>中，当线路数据传到这个页面时，需要再次加工才能获得该页面所需要的信息（比如哪个站是换乘站、一共需要换乘几次、计算合理的末班车时间等），而这个工作全部放到了当前ViewController中进行。再加上其他一些处理逻辑，导致这个ViewController变得极端臃肿，达到了令人发指的3000多行。</p><p>再比如切换不同城市地铁的<code>城市列表页</code>中，由于没有做好适当的分层，导致这个ViewController除了显示城市列表的任务之外，还承担了：</p><ul><li>点选切换城市之后的数据初始化工作；</li><li>点选开始下载后的进度更新逻辑，甚至下载完成后的解压逻辑；</li><li>点选删除城市之后的数据清理工作；</li><li>…</li></ul><h3 id="耦合过紧"><a href="#耦合过紧" class="headerlink" title="耦合过紧"></a>耦合过紧</h3><p>从上面的结构模块示意图中可以看出，在不同模块之间存在着错综复杂的强依赖，其中尤以<code>DataSource</code>最为严重，因为在整个App运行期间都要保持不同界面的某种数据一致性。虽然在之前的架构中特地抽象出了DataSource这个单例，但各个模块间都是直接对其进行操作，不仅繁琐、容易出错，从架构的角度来看，某些底层的操作完全不应该由最上层的ViewController来做。</p><p>再举个例子，在3.x版本的地图控件中（即上图的<code>TileView</code>），存在着大量处理和用户交互的代码逻辑，甚至还有用户点选起点和终点后直接对<code>DataSource</code>进行更新的逻辑。过紧的耦合导致了不必要的判断，到现在我都无法完全搞清之前同事写的下面这几行代码中，那两个神奇的数字到底是干嘛的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> tag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ([sender isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *tmpBtn = (<span class="built_in">UIButton</span> *)sender;</span><br><span class="line">    tag = tmpBtn.tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sender == bubbleView.startBtn || tag == <span class="number">888</span> || tag == <span class="number">887</span>) &#123; <span class="comment">// WTF??</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="产品逻辑混乱"><a href="#产品逻辑混乱" class="headerlink" title="产品逻辑混乱"></a>产品逻辑混乱</h3><p>这条看起来可能有点甩锅的意思，但实际情况确实如此：如果有哪条逻辑写起来非常拧巴，或者连描述起来都拧巴的时候，你可以去认真思考一下，是不是从产品设计上就出了问题。</p><p>虽然从流程上讲，这种上溯应该扼杀在需求评审之类的时机，但从实际执行的角度，已经完成的功能并不代表就是不可更改的。尤其在发现那部分代码已经成为维护地狱的时候，应该当机立断进行修正。</p><p>比如在书签/历史线路页面，以前产品的需求是查询过的站点和线路按时间逆序混杂在一起显示，这样导致的结果就是，在构造这个页面时需要大量的动态判断逻辑来区分每个cell到底是什么东西：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [historyMArray objectAtIndex:row];</span><br><span class="line"><span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:[Route <span class="keyword">class</span>]])&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cell;</span><br></pre></td></tr></table></figure><p>而如果把页面分为若干个section显示，不仅从根源上杜绝了这种混乱的逻辑，从产品的角度也使用户一眼看上去更加清晰。</p><h3 id="页面布局方式过时"><a href="#页面布局方式过时" class="headerlink" title="页面布局方式过时"></a>页面布局方式过时</h3><p>可能对于大部分现有的App来说，这已经不算是个问题，但对于一个有着几年历史的App，基本上最早的那些界面依然是用绝对坐标进行定位的；加载一个动态生成的UI时，也是一点点计算后再<code>addSubview</code>上去，或者修改某个控件的<code>frame.size.height</code>来更新其高度。这种做法不仅不优雅，更重要的是不直观。一切不直观的代码都会导致以下几点问题：</p><ul><li>开发时难以调试；</li><li>出现bug时难以维护；</li><li>拿到新需求时难以修改。</li></ul><p>所谓的KISS原则（Keep It Simple &amp; Stupid），指的就是这样的场景。</p><p><br></p><p>知道了现有的问题，下面要做的就是一些合理的规划了。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>有了上面所述的教训，在设计新版架构的时候，从最开始就确立了几条原则：</p><ol><li>尽量打散耦合，只在有必要的情况下采用紧耦合；</li><li>切记合理封装，每个模块严格只负责自己的事务；</li><li>争取保持简洁，遇到复杂的实现换用简单的设计。</li></ol><p>下面是我当时在日记本上画的下载模块的层次结构示意图：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7y17wt9lbj21kw0yoe0i.jpg" alt=""></p><p>每一层之间仅保留最基本的数据请求和数据反馈。</p><p>新的结构图大概是这个样子：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7y26hsd5tj21g412m44r.jpg" alt=""></p><p>最明显的区别就是把模块之间的紧耦合变成了虚线显示的Notification，并且去掉了所有跨级调用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始项目之前，一个要做的选择是，要用原有的Objective-C还是新生的Swift？</p><p>最终我选择了Swift。理由是：</p><ol><li>Swift经过几年的发展，已经趋于稳定；</li><li>此次重写的目标就是要面向未来，而Swift就是未来；</li><li>借机学习新的技术。</li></ol><p>然后，我用”Swift best practices”作为关键词搜索进行了一番调研，尽量从最开始就站在巨人的肩膀上，往正确的方向走。</p><p>比如这篇：<a href="https://github.com/futurice/ios-good-practices">https://github.com/futurice/ios-good-practices</a></p><p>一些在项目中采纳的点：</p><h3 id="使用struct来定义常量"><a href="#使用struct来定义常量" class="headerlink" title="使用struct来定义常量"></a>使用<code>struct</code>来定义常量</h3><p>在Objective-C时代经常用<code>#define</code>来定义常量，现在可以使用<code>struct</code>来定义。比如：<br>    <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CMConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">AppName</span>: <span class="type">String</span>          <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">AppStoreID</span> : <span class="type">UInt</span>        <span class="operator">=</span> <span class="number">8888</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">WeiboKey</span>: <span class="type">String</span>         <span class="operator">=</span> <span class="string">&quot;8888&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">WeiboAppSecret</span>: <span class="type">String</span>   <span class="operator">=</span> <span class="string">&quot;8888&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">AppStoreURL</span>: <span class="type">NSURL</span>       <span class="operator">=</span> <span class="type">NSURL</span>(string: <span class="string">&quot;itms-apps://itunes.apple.com/cn/app/bei-jing-de-tie-touchchina/id530096786&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样可以最大程度地利用Swift<em>类型安全</em>的语言特性，使你在编译期就可以检查出一些低级的失误。</p><h3 id="使用Asset-Catalogs来图像资源文件"><a href="#使用Asset-Catalogs来图像资源文件" class="headerlink" title="使用Asset Catalogs来图像资源文件"></a>使用<code>Asset Catalogs</code>来图像资源文件</h3><p>之前的图像资源管理非常混乱，不仅所有文件混杂在目录中，而且每个资源对应着两到三个不同分辨率的@2x, @3x传统位图。</p><p>采取Asset Catalog进行统一管理后，不仅工程干净清爽了许多，还可以用一张矢量图来让XCode自动为你生成不同分辨率的资源。记得我刚才说的“面向未来”吗？xD</p><p>（没错，矢量图是我自己拿Adobe Illustrator重绘的。）</p><h3 id="设定合理的Logging策略"><a href="#设定合理的Logging策略" class="headerlink" title="设定合理的Logging策略"></a>设定合理的Logging策略</h3><p>之前的项目中一直采用<code>NSLog</code>，这样的弊端是在正式上线的App中很难把所有NSLog都屏蔽掉，而这些输出的记录会影响程序效能，还可能泄露隐私。</p><p>如果在一开始就设定合理的Logging分级机制，这样在打发布包的时候只需把Looging Level调高（甚至可以在切换scheme的时候自动进行调整），就能杜绝上述问题。</p><h3 id="使用预处理标志"><a href="#使用预处理标志" class="headerlink" title="使用预处理标志"></a>使用预处理标志</h3><p>直接看图：<br>    <img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7yui16xaej20y3046q44.jpg" alt=""></p><p>使用Preprocessor Symbol的好处是什么呢？还以刚才的常量定义为例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CMConfig</span> </span>&#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"><span class="keyword">#if</span> <span class="type">Debug</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">BaseURL</span> : <span class="type">NSURL</span>          <span class="operator">=</span> <span class="type">NSURL</span>(string: <span class="string">&quot;https://test.itouchchina.com&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMBPushMode</span> : <span class="type">BPushMode</span>  <span class="operator">=</span> <span class="type">BPushMode</span>.<span class="type">Development</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMLogLevel</span> : <span class="type">SLogLevel</span>   <span class="operator">=</span> <span class="type">SLogLevel</span>.<span class="type">Verbose</span> <span class="comment">// 百度推送模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMDebugStatus</span> : <span class="type">Bool</span>     <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMHeaderClass</span>: <span class="type">String</span>    <span class="operator">=</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">BaseURL</span> : <span class="type">NSURL</span>          <span class="operator">=</span> <span class="type">NSURL</span>(string: <span class="string">&quot;https://production.itouchchina.com&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMBPushMode</span> : <span class="type">BPushMode</span>  <span class="operator">=</span> <span class="type">BPushMode</span>.<span class="type">Production</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMLogLevel</span> : <span class="type">SLogLevel</span>   <span class="operator">=</span> <span class="type">SLogLevel</span>.<span class="type">Error</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMDebugStatus</span> : <span class="type">Bool</span>     <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CMHeaderClass</span>: <span class="type">String</span>    <span class="operator">=</span> <span class="string">&quot;production&quot;</span></span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此便可以一劳永逸地解决各种常量在开发版和正式版中的切换问题，你从此可以忘掉它，在切换scheme的时候一切都会自动调整，免去了可能的错误。</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7yyy6rullj20b606mdgl.jpg" alt=""></p><p>如果你有更多的scheme，希望更细粒度地进行控制，可以使用Swift Flag:</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7yxhrdxltj20tb04yq3v.jpg" alt=""></p><p>在此不再赘述。</p><h3 id="使用CocoaPods进行第三方库管理"><a href="#使用CocoaPods进行第三方库管理" class="headerlink" title="使用CocoaPods进行第三方库管理"></a>使用CocoaPods进行第三方库管理</h3><p>这点应该大家都熟悉，<strong>谁用谁知道</strong>。</p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>下面选几个有代表性的页面，分别说明一下改进的细节。</p><h3 id="城市列表页"><a href="#城市列表页" class="headerlink" title="城市列表页"></a>城市列表页</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>如前所述，UI层代码、交互层代码、响应层代码和数据处理以及初始化代码没有合理分离。</li><li><p>城市的下载状态没有一个统一的位置持有。<br> 设计者的本意是通过进入该页面时生成的一个包含所有City实例的<code>NSArray</code>管理，可一旦开始下载，就要涉及<code>DownloadManager</code>模块里面的下载状态和当前页面数组中的状态之间的同步等一系列问题。<br> 同时，我们会发现每次在设置城市的下载状态时都会进行很多判断，这些判断还有不少是重复的。更严重的问题是，一个后续的错误状态也许会覆盖掉之前设置过的正确状态（因为在局部没有足够的上下文信息对状态进行充分的判断）。</p><p> 举个例子：</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cell.state == <span class="built_in">CGListTableCellStateEdit</span>) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * versionFile = getCGDocumentPath([<span class="built_in">NSString</span> stringWithFormat: <span class="string">@&quot;guides/guide%d/current.version&quot;</span>, [guide.metroAppId intValue]]);</span><br><span class="line">    <span class="built_in">NSString</span> * version = [<span class="built_in">NSString</span> stringWithContentsOfFile: versionFile encoding: <span class="built_in">NSUTF8StringEncoding</span> error: <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([fm fileExistsAtPath:versionFile]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((version != <span class="literal">nil</span>) &amp;&amp; ([guide.guideupdate compare: version] != <span class="built_in">NSOrderedSame</span>))</span><br><span class="line">            cell.guide.cellState = <span class="built_in">CGListTableCellStateUpdate</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cell.guide.cellState = <span class="built_in">CGListTableCellStateDownloaded</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cell.guide.cellState = <span class="built_in">CGListTableCellStateDownloaded</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> reloadTableView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这只是一个简单的当用户点击一个<strong>编辑状态</strong>的城市时应该采取的动作，但此处的实现居然恐怖到动用了一个<code>NSFileManager</code>！而这一切仅仅是为了判断这个城市应该回复到<strong>已下载</strong>状态还是<strong>有更新</strong>状态。</p><p> 类似的代码还可以见到好几处（在该页搜索<code>NSFileManager</code>，有多达19个结果！）。</p></li><li><p>最后一个问题也是上面提到的，搭建UI采用绝对坐标。<br> 甚至有这样恶心的代码：</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)formatUI&#123;</span><br><span class="line">    <span class="built_in">CGSize</span> size = [cityNameLabel.text sizeWithFont:cityNameLabel.font];</span><br><span class="line">    <span class="built_in">CGRect</span> rect;</span><br><span class="line">    rect = cityNameLabel.frame;</span><br><span class="line">    rect.size.width = size.width;</span><br><span class="line">    cityNameLabel.frame = rect;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size.width &gt; <span class="number">74</span>) &#123; <span class="comment">// Why 74?</span></span><br><span class="line">        <span class="built_in">CGRect</span> rect;</span><br><span class="line">        rect = sizeLabel.frame;</span><br><span class="line">        rect.origin.x = <span class="number">80</span> + size.width - <span class="number">74</span>; <span class="comment">// ???</span></span><br><span class="line">        sizeLabel.frame = rect;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><h5 id="下载管理"><a href="#下载管理" class="headerlink" title="下载管理"></a>下载管理</h5><p>在地铁通4.0中，我把所有对下载状态的管理一概收到了下载模块<code>CMDataAPI</code>中，现在获取下载状态只要一行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentMode: <span class="type">CMCityListCellMode</span> <span class="operator">=</span> <span class="type">CMDataAPI</span>.sharedInstance.getModeForCity(city)</span><br></pre></td></tr></table></figure><p>在<code>getModeForCity(_city: CMCity)</code>的实现中，只需遍历下载和解压两个队列，如果有必要对结果再进行时间戳的比对即可。（顺便，我把下载的时间戳迁移到了<code>NSUserDefaults</code>里，避免了文件操作，并在运行时做了缓存。）</p><h5 id="进度更新"><a href="#进度更新" class="headerlink" title="进度更新"></a>进度更新</h5><p>而下载进度和解压进度的更新，也被封装成了两个方法，只暴露给调用页面需要的参数（之前的版本中，解压进度甚至是无法查看的）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">hookUpDownloadingProgress</span></span></span><br><span class="line"><span class="function">        (<span class="params">_progress</span>: ((<span class="type">UInt</span>, <span class="type">Int64</span>, <span class="type">Int64</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>,</span></span><br><span class="line"><span class="function">        <span class="params">success</span>: (<span class="type">CMCity</span> -&gt; <span class="type">Void</span>)<span class="operator">?</span>,</span></span><br><span class="line"><span class="function">        <span class="params">failure</span>: (<span class="type">CMCity</span> -&gt; <span class="type">Void</span>)<span class="operator">?</span>,</span></span><br><span class="line"><span class="function">        <span class="params">forCity</span> <span class="params">city</span>: <span class="type">CMCity</span>)</span>&#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">hookUpUnzippingProgess</span></span></span><br><span class="line"><span class="function">        (<span class="params">_progress</span>: ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>,</span></span><br><span class="line"><span class="function">        <span class="params">success</span>: (<span class="type">CMCity</span> -&gt; <span class="type">Void</span>)<span class="operator">?</span>,</span></span><br><span class="line"><span class="function">        <span class="params">forCity</span>: <span class="params">city</span>: <span class="type">CMCity</span>)</span>&#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="与地图页的解耦合"><a href="#与地图页的解耦合" class="headerlink" title="与地图页的解耦合"></a>与地图页的解耦合</h5><p>在切换城市时，对地图页的直接调用改为发<code>NSNotification</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">PropertyKeys</span>.kCMCityChangeNotification, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>注意所有的广播名称常量也用前述的<code>struct</code>进行了统一的定义。</p><h5 id="转移数据操作"><a href="#转移数据操作" class="headerlink" title="转移数据操作"></a>转移数据操作</h5><p>所有的数据初始化全部移到<code>CMDataSource</code>中进行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">CMDataSource</span>.sharedInstance.loadCity(city) <span class="comment">// One line to rule them all!</span></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), &#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="type">SVProgressHUD</span>.dismiss()</span><br><span class="line">        <span class="keyword">self</span>.navigationController<span class="operator">?</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除城市数据亦然：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CMDataSource</span>.sharedInstance.removeCity(city)</span><br></pre></td></tr></table></figure><h5 id="使用Storyboard-Xib"><a href="#使用Storyboard-Xib" class="headerlink" title="使用Storyboard/Xib"></a>使用Storyboard/Xib</h5><p>将UI搭建改为Storyboard/Xib这件事早有很多讨论，略去不表。</p><h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><table><thead><tr><th>文件</th><th style="text-align:center">地铁通V3.x</th><th style="text-align:center">地铁通V4.0</th></tr></thead><tbody><tr><td>CityListViewController</td><td style="text-align:center">1712行</td><td style="text-align:center">280行</td></tr><tr><td>CityListCell</td><td style="text-align:center">与上面是同一个文件</td><td style="text-align:center">123行</td></tr></tbody></table><h3 id="线路结果页"><a href="#线路结果页" class="headerlink" title="线路结果页"></a>线路结果页</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ol><li><p>如前所述，对于线路数据需要再进行加工才能使用。</p><p> 如图，光是确定各种情况下的末班车时间就有下面一大堆方法：<br> <img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7z9j3titcj20se09a0vl.jpg" alt=""></p><p> 在<code>tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code>里就更加惨不忍睹。</p></li><li><p>这个页面在搭建UI上的问题更加严重。<br> 由于每次生成的路线有无数种可能的组合，比如该城市的数据库中有没有出租车信息、起点终点是地铁站还是用户输入的地点、进行百度/Google搜索时有搜索中和搜索完成/失败三种状态……导致整个UI是在不停变化的，而未采用AutoLayout中约束条件的弊端在这种情况下体现得淋漓尽致。</p><p> 恶心代码欣赏：</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (taxiFee.floatValue &lt; <span class="number">0.01</span>) &#123;</span><br><span class="line">    [headerView removeTaxi];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(discountRate &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    [headerView setDiscountRateUI];</span><br><span class="line">    <span class="built_in">CGRect</span> headerFrame = headerView.frame;</span><br><span class="line">    headerFrame.size.height += <span class="built_in">CM_ROUTE_SUM_MARGIN</span>;</span><br><span class="line">    headerView.frame = headerFrame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 曾经设计师在挑UI问题的时候提出某处的空白留的不够，当时的我盘算了下在这种纷杂状况下想要精确控制空白高度的工作量……决定把这个bug放到最后再改，后来其他需求一来就不了了之了……</p></li><li><p>直接操作现象。<br> 在数据变动要更新UI的时候，经常出现直接去更新相关View控件的代码。初看起来这没什么问题，但还是刚才说的问题，当这涉及到控件大小的改动时，就非常令人头疼了。</p></li></ol><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><h5 id="引入新数据类型"><a href="#引入新数据类型" class="headerlink" title="引入新数据类型"></a>引入新数据类型</h5><p>引入新的<code>Route</code>和<code>RouteNode</code>对象，将所有与表现层无关的数据构建代码一律移入这里。</p><p>顺便，还为今后可能的变动做了扩展：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(<span class="params">start</span>:<span class="type">CMPOI</span>, <span class="params">end</span>:<span class="type">CMPOI</span>, <span class="params">algorithm</span>: <span class="type">CMRouteAlgorithm</span>, <span class="params">type</span>: <span class="type">CMRouteType</span>)</span></span><br></pre></td></tr></table></figure></p><p>在初始化对象的时候灵活传入所需的算法，可以实现灵活变换不同的算法计算路线。之前出现过针对海外城市采取不同的路线计算方式，当时的实现弄得非常恶心，这样就优雅很多。</p><p>再顺便，这是<code>策略模式</code>——在面试中经常被问到“你在项目中用了什么设计模式”这种恶心的问题，特地查了一下这种抽象叫什么。</p><p>现在，即使是返回cell的回调方法里也清晰多了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAtIndexPath</span> <span class="params">indexPath</span>: <span class="type">NSIndexPath</span>)</span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node <span class="operator">=</span> routeArray[indexPath.row]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> type <span class="operator">=</span> node.type, <span class="keyword">let</span> lineId <span class="operator">=</span> node.lineId&#123;</span><br><span class="line">        <span class="keyword">switch</span> type&#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">TimeAdjusting</span>:</span><br><span class="line">            <span class="keyword">var</span> cell: <span class="type">CMRouteTimeAdjustingCell</span>? <span class="operator">=</span> tableView.dequeueReusableCellWithIdentifier(<span class="type">TimeAdjustingCellId</span>) <span class="keyword">as?</span> <span class="type">CMRouteTimeAdjustingCell</span></span><br><span class="line">            <span class="keyword">if</span> cell <span class="operator">==</span> <span class="literal">nil</span>&#123;</span><br><span class="line">                cell <span class="operator">=</span> <span class="type">CMRouteTimeAdjustingCell</span>(style: <span class="type">UITableViewCellStyle</span>.<span class="type">Default</span>, reuseIdentifier: <span class="type">TimeAdjustingCellId</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="operator">...</span> <span class="comment">// Initialization code</span></span><br><span class="line">            <span class="keyword">return</span> cell<span class="operator">!</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Normal</span>:</span><br><span class="line">            <span class="keyword">var</span> cell: <span class="type">CMRouteNormalStationCell</span>? <span class="operator">=</span> tableView.dequeueReusableCellWithIdentifier(<span class="type">NormalStationCellId</span>) <span class="keyword">as?</span> <span class="type">CMRouteNormalStationCell</span></span><br><span class="line">            <span class="operator">...</span> <span class="comment">// Same as above</span></span><br><span class="line">            <span class="keyword">return</span> cell<span class="operator">!</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">POI</span>:</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">            <span class="keyword">return</span> cell<span class="operator">!</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Transfer</span>, .<span class="type">Start</span>, .<span class="type">Destination</span>:</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">            <span class="keyword">return</span> cell<span class="operator">!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UITableViewCell</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="使用约束条件建立UI"><a href="#使用约束条件建立UI" class="headerlink" title="使用约束条件建立UI"></a>使用约束条件建立UI</h5><p>现在，整个页面，包括cell，都是用Constraints建立起来的（使用了一个第三方库叫<a href="http://snapkit.io/">SnapKit</a>）。</p><p>而且，cell里面的地铁线路，是用<code>CoreGraphic</code>自己画的。</p><p>甚至，线路上的文字是黑色还是白色，都是通过算法自动生成的（参考了<a href="http://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color">这里</a>的讨论）。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7zcoe3fqsj20ku111jvd.jpg" width="60%"></p><p>这样的灵活度基本上算是达标了:)</p><p>PS. 在完成整个项目之后，我试着把新版app在iPad上跑了一下，惊讶地发现，在我没有改动任何地方的情况下，居然所有页面的UI都显示正常！这在引入约束条件生成UI之前简直是不可想象的。</p><h5 id="只更新数据源，不操作控件"><a href="#只更新数据源，不操作控件" class="headerlink" title="只更新数据源，不操作控件"></a>只更新数据源，不操作控件</h5><p>事实上，这就是最基本的MVC分层在实际中的应用——当数据变化时，产生变化的组件只负责更新<code>DataModel</code>，然后简单地调用<code>tableView.reloadData()</code>搞定。剩下的问题都由<code>View</code>层自行负责。</p><p>后来在浏览博客时发现有关这样的改动，Eden有一篇<a href="http://studentdeng.github.io/blog/2014/08/29/ios-architecture/">《iOS APP 架构漫谈》</a>差不多是同样的场景，在那篇文章中解释得非常详尽，尤其是：</p><blockquote><p>我们可以借鉴很多”内存管理中的规则”，比如<code>谁创建，谁销毁</code>。同样，在我们的information flow中，我们希望<code>谁创建Cache，谁更新Cache变化</code></p></blockquote><p>这一句，道破本质。有兴趣的可去观摩。</p><h5 id="成果-1"><a href="#成果-1" class="headerlink" title="成果"></a>成果</h5><table><thead><tr><th>文件</th><th style="text-align:center">地铁通3.x</th><th style="text-align:center">地铁通4.0</th></tr></thead><tbody><tr><td>RouteViewController</td><td style="text-align:center">3055行</td><td style="text-align:center">1158行</td></tr><tr><td>RouteViewCell</td><td style="text-align:center">158+67+171+89+220+249+245<br>=1199行&lt;1&gt;</td><td style="text-align:center">400行</td></tr><tr><td>Route&lt;2&gt;</td><td style="text-align:center">1045行</td><td style="text-align:center">N/A</td></tr><tr><td>DataModel&lt;3&gt;</td><td style="text-align:center">N/A</td><td style="text-align:center">629行</td></tr><tr><td>DijkstraAlgorithm&lt;4&gt;</td><td style="text-align:center">N/A</td><td style="text-align:center">320行</td></tr></tbody></table><p>注：</p><ol><li>3.x版本中分为NormalCell、TransferCell、HeaderView、SummaryView等许多文件；</li><li>3.x版本中的Route文件其实是算法，生成一个不包含meta信息的<code>NSArray</code>；</li><li>4.0版本中的DataModel定义了程序所需的所有底层对象，不仅有Route，还有下载的城市以及车站等等；</li><li>这是计算图上两点间最短路径的Dijkstra算法的实现，从之前的Route文件中抽了出来。</li></ol><h3 id="书签-历史页"><a href="#书签-历史页" class="headerlink" title="书签/历史页"></a>书签/历史页</h3><p>这个页面之前也提到过，主要问题是设计太混乱。</p><p>修改之后的逻辑相当的简洁，想出错都难：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> indexPath.section <span class="operator">==</span> <span class="number">0</span>&#123;<span class="comment">//routes</span></span><br><span class="line">    <span class="keyword">let</span> route <span class="operator">=</span> favRoutes[indexPath.row]</span><br><span class="line">    <span class="keyword">return</span> getRouteCell(route <span class="keyword">as!</span> <span class="type">NSDictionary</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//stations</span></span><br><span class="line">    <span class="keyword">let</span> station <span class="operator">=</span> favStations[indexPath.row]</span><br><span class="line">    <span class="keyword">return</span> getStationCell(station)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成果是：</p><table><thead><tr><th>文件</th><th style="text-align:center">地铁通3.x</th><th style="text-align:center">地铁通4.0</th></tr></thead><tbody><tr><td>BookmarkViewController</td><td style="text-align:center">784行</td><td style="text-align:center">315行</td></tr><tr><td>BookmarkCell</td><td style="text-align:center">109+98+105=312行</td><td style="text-align:center">90行</td></tr></tbody></table><h3 id="车站详情页"><a href="#车站详情页" class="headerlink" title="车站详情页"></a>车站详情页</h3><p>这个页面的代码量与之前基本保持一致，不同的是整体的UI搭建逻辑。</p><p>之前的搭法：从上到下依次初始化子控件并添加，保持一个<code>position</code>变量记录当前高度。</p><p>新版中的搭法：每个子控件负责处理自己的UI展现，子控件之间用约束条件加以绑定。</p><p>由于这个页面的数据都是不确定的，因此只能用代码添加数据元素间的约束条件，这是与前面那些大体UI已定好只待往里填数据的页面不同的地方。</p><p>最终的画风大概是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">scrollView.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">scrollView.addSubview(titleBackgroundView)</span><br><span class="line">scrollView.addSubview(timetableView)</span><br><span class="line">scrollView.addSubview(facilitiesView)</span><br><span class="line">scrollView.addSubview(exitView)</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(scrollView)</span><br><span class="line"></span><br><span class="line">scrollView.snp_makeConstraints &#123; (make) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    make.top.equalTo(<span class="keyword">self</span>.view.snp_top)</span><br><span class="line">    make.width.equalTo(<span class="keyword">self</span>.view.snp_width)</span><br><span class="line">    make.bottom.equalTo(floatingBGView.snp_top)</span><br><span class="line">&#125;</span><br><span class="line">titleBackgroundView.snp_makeConstraints &#123; (make) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    make.top.equalTo(scrollView.snp_top).priorityRequired()</span><br><span class="line">    make.width.equalTo(scrollView.snp_width).priorityRequired()</span><br><span class="line">&#125;</span><br><span class="line">timetableView.snp_makeConstraints &#123; (make) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    make.top.equalTo(titleBackgroundView.snp_bottom).offset(<span class="number">10.0</span>)</span><br><span class="line">    make.width.equalTo(scrollView.snp_width)</span><br><span class="line">    make.centerX.equalTo(scrollView.snp_centerX)</span><br><span class="line">&#125;</span><br><span class="line">facilitiesView.snp_makeConstraints &#123; (make) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    make.top.equalTo(timetableView.snp_bottom).offset(<span class="number">20.0</span>)</span><br><span class="line">    make.width.equalTo(scrollView.snp_width)</span><br><span class="line">    make.leading.equalTo(scrollView.snp_leading)</span><br><span class="line">&#125;</span><br><span class="line">exitView.snp_makeConstraints &#123; (make) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    make.top.equalTo(facilitiesView.snp_bottom).offset(<span class="number">20.0</span>)</span><br><span class="line">    make.leading.equalTo(scrollView.snp_leading)</span><br><span class="line">    make.width.equalTo(scrollView.snp_width)</span><br><span class="line">    make.bottom.equalTo(scrollView.snp_bottom).offset(<span class="operator">-</span><span class="type">Constants</span>.<span class="type">StationDetailViewVerticalSpacing</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> _station <span class="operator">=</span> station&#123;</span><br><span class="line">    titleLabel.text <span class="operator">=</span> _station.stationName</span><br><span class="line">    iconsDisplayView.setImages(_station.getIcons())</span><br><span class="line">    timetableView.setup(_station.timeTables)</span><br><span class="line">    facilitiesView.setupUI(_station.facilities)</span><br><span class="line">    exitView.setupUI(_station.exits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI约束与数据初始化一气呵成，而且清晰明了。（顺便感谢Swift的链式语法）</p><h3 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h3><p>用到搜索页的地方有两处，一个是首页点击最上方进入的页面，一个是首页点击下方右边按钮进入的页面。两者的不同是：前者有输入起点和终点的工具栏，后者只是单纯搜索定位车站。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7ztpzxw31j21jk0xcn1y.jpg" alt=""></p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><ol><li>之前的版本的两个界面完全独立，等于许多逻辑重复了两遍，违背了DRY(Don’t Repeat Yourself)原则。</li><li><p>和线路详情页类似，此处也缺少对数据合理的对象化封装，导致在使用时需要大量的判断逻辑。<br> 比如，会出现下面这样的代码片段：</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([workDict objectForKey:<span class="string">@&quot;city&quot;</span>] != <span class="literal">nil</span> &amp;&amp; [[workDict objectForKey:<span class="string">@&quot;city&quot;</span>] isEqualToString:_cityName]) &#123;</span><br><span class="line">    _isShowingWork = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> ([workDict objectForKey:<span class="string">@&quot;add&quot;</span>] == <span class="literal">nil</span>) &#123; <span class="comment">// Station</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// POI</span></span><br><span class="line">        [<span class="keyword">self</span> updateHistoryItem:workDict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">// Have not set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这种直接对原始数据进行操作的做法实在是既繁琐又容易出错。</p></li><li>对子控件的直接更新，这点和前面的线路结果页类似，但更加麻烦：由于当前编辑状态在随时变化，在决定更新控件时必须由零碎的变量来辅助判断到底要对哪个控件进行操作。<br> 比如在百度定位API返回结果之后，下面的这段响应代码： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    - (<span class="keyword">void</span>)updatePOIFromLocation:(BMKPoiInfo *)info&#123;</span><br><span class="line">    Station *station = [[<span class="built_in">CMDataSource</span> getInstance] getNearestStation:info.pt.latitude andLo:info.pt.longitude];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isUpdatingStart) &#123;</span><br><span class="line">        ... <span class="comment">// Do some work</span></span><br><span class="line">        <span class="keyword">self</span>.currentEditing = <span class="built_in">CMSearchEditingEnd</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isUpdatingEnd)&#123;</span><br><span class="line">        ... <span class="comment">// Doing work</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isUpdatingStart) &#123;</span><br><span class="line">        isUpdatingStart = <span class="literal">NO</span>;</span><br><span class="line">        _startIsShowingLocation = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isUpdatingEnd) &#123;</span><br><span class="line">        isUpdatingEnd = <span class="literal">NO</span>;</span><br><span class="line">        _endIsShowingLocation = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>又要凭借状态变量进行判断，又要记得时刻更新它们，还得防止考虑不周更新错了状态，简直是车祸现场。</li></ol><h4 id="改进-2"><a href="#改进-2" class="headerlink" title="改进"></a>改进</h4><h5 id="合并两个页面"><a href="#合并两个页面" class="headerlink" title="合并两个页面"></a>合并两个页面</h5><p>我直接把两个页面合并到了一起，由入口参数决定最终显示哪个界面。</p><p>但后来意识到，这并不是最好的解决方案。弊端是，原来是毫无耦合造成重复，现在两个页面的耦合又太紧了，虽然在这版的需求中工作得很好，再有调整又会比较棘手。更好的做法是使用<code>组合</code>，把公共的列表提取出来。</p><p>这一点在Casa的<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html">《跳出面向对象思想(一) 继承》</a>中解释得非常好，我就不再赘述。</p><h5 id="新定义数据对象"><a href="#新定义数据对象" class="headerlink" title="新定义数据对象"></a>新定义数据对象</h5><p>在前面提到的<code>DataModel</code>中增加了<code>POI</code>对象，包含<code>Station</code>作为它的一个property。</p><p>这代表，现在整个界面中，甚至整个app运行期间，都只有一种数据对象——<code>CMPOI</code>，清爽，干净，不紧绷。</p><h5 id="只更新数据源，不操作控件-1"><a href="#只更新数据源，不操作控件-1" class="headerlink" title="只更新数据源，不操作控件"></a>只更新数据源，不操作控件</h5><p>基本同前，不赘述。</p><h5 id="成果-2"><a href="#成果-2" class="headerlink" title="成果"></a>成果</h5><table><thead><tr><th>文件</th><th style="text-align:center">地铁通3.x</th><th style="text-align:center">地铁通4.0</th></tr></thead><tbody><tr><td>SearchStationViewController</td><td style="text-align:center">2019行</td><td style="text-align:center">469行</td></tr><tr><td>StationSearchView</td><td style="text-align:center">821行</td><td style="text-align:center">N/A</td></tr></tbody></table><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><h4 id="明确职责"><a href="#明确职责" class="headerlink" title="明确职责"></a>明确职责</h4><p>这个组件作为整个app的数据中心，在新版的开发中更加明确了它的职责，把原来分散在其他组件中的一些功能划了过来。</p><p>比如，之前城市列表读取及解析功能是被划到网络请求组件中的，因为从服务器拿过来的返回数据可以就地解析；但从更高层的逻辑考虑这是不正确的，因为对程序城市列表的需求是更直接的，网络模块只要做好本职的网络交互就行了。</p><p>修改之后，网络请求组件读取成功城市列表后，并不直接返回，而是将列表保存到本地缓存起来，再发一个Notification通知到关心读取成功这个事件的其他组件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateCityList</span>()</span>&#123;</span><br><span class="line">    <span class="operator">...</span> <span class="comment">// Initialization code for paramaters</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> param: [<span class="type">String</span> : <span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;param&quot;</span>: <span class="type">JSONStringParam</span>]</span><br><span class="line">        </span><br><span class="line">    manager.<span class="type">POST</span>(url, parameters: param, success: &#123; (opreation, object) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> object <span class="keyword">as!</span> <span class="type">NSData</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">CMDataSource</span>.sharedInstance.loadXMLResponse(data) <span class="operator">==</span> <span class="literal">true</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> documentPath <span class="operator">=</span> getDocumentPath(<span class="string">&quot;guides/guides.info&quot;</span>)</span><br><span class="line">            data.writeToFile(documentPath, atomically: <span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">PropertyKeys</span>.kCMCityListUpdateSuccessNotification, object: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) &#123; (opreation, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="operator">...</span> <span class="comment">// Error handler</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将组件间的耦合降到最低。另外注意这段代码中对返回结果的解析已经移到<code>DataSource</code>了。</p><h4 id="减少耦合"><a href="#减少耦合" class="headerlink" title="减少耦合"></a>减少耦合</h4><p>正如上面提到的做法，之前诸多对<code>DataSource</code>直接的操作，在这一版中有许多都改为了通过Notification交互：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">init</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cityComponents <span class="operator">=</span> getCityListFromFile()</span><br><span class="line">        </span><br><span class="line">    <span class="operator">...</span> <span class="comment">// Data initialization</span></span><br><span class="line">        </span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, #selector(<span class="type">CMDataSource</span>.didSetStart()), name: <span class="type">PropertyKeys</span>.kCMSetStartStationNotification, object: <span class="literal">nil</span>)</span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, #selector(<span class="type">CMDataSource</span>.didSetEnd()), name: <span class="type">PropertyKeys</span>.kCMSetEndStationNotification, object: <span class="literal">nil</span>)</span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, #selector(<span class="type">CMDataSource</span>.didRemoveStart()), name: <span class="type">PropertyKeys</span>.kCMRemoveStartNotification, object: <span class="literal">nil</span>)</span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, #selector(<span class="type">CMDataSource</span>.didRemoveEnd()), name: <span class="type">PropertyKeys</span>.kCMRemoveEndNotification, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">deinit</span>&#123;</span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于与上面谈到的改进点比较接近的页面，限于篇幅不再赘述，只在此处一并提及：</p><ul><li><code>地图View</code>，去掉了与上层的所有耦合，交互改为发<code>NSNotification</code>；同时将地图上要显示的控件统一到一个<code>protocol</code>之下，这样就可以利用Swift新提供的<code>泛型</code>特性，写出很强一致性的代码：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func updateCoor&lt;T: TiledScrollViewOverlay where T: UIView&gt;(_view: T, zoom: Bool)&#123;</span><br><span class="line">    ... // Update code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>网络请求模块</code>，上面已有提及，在移除不属于自身逻辑的同时，重新整理了解析数据的时机（原来的版本中居然重复着极为相似的三段代码！又一个车祸现场）；</li><li><p><code>分享模块</code>，之前的封装使用非常繁琐，每次还要自行加到UIWindow上去。于是又重新写了一个，弹出分享控件只需下面几步：</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shareKit: <span class="type">CMShareKit</span> <span class="operator">=</span> <span class="type">CMShareKit</span>.getInstance()</span><br><span class="line">shareKit.setup(<span class="string">&quot;分享文字&quot;</span>, </span><br><span class="line">    emailBody: <span class="string">&quot;邮件文字&quot;</span>, </span><br><span class="line">    smsBody: shareContent, </span><br><span class="line">    weixinTitle: appName, </span><br><span class="line">    weixinBody: shareContent, </span><br><span class="line">    weixinPengyouBody: shareContent, </span><br><span class="line">    weixinURL: <span class="type">CMConfig</span>.<span class="type">AppDownloadURLTrim</span>.absoluteString, </span><br><span class="line">    qqTitle: appName, </span><br><span class="line">    qqBody: shareContent, </span><br><span class="line">    qqURL: <span class="type">CMConfig</span>.<span class="type">AppDownloadURLTrim</span>.absoluteString, </span><br><span class="line">    weiboBody: shareContent, </span><br><span class="line">    image: <span class="keyword">self</span>.getCurrentViewShot())</span><br><span class="line">shareKit.show(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p>  后来看到Matt Gemmell在他的<a href="http://mattgemmell.com/api-design/">《API Design》</a>这篇blog中也不谋而合地提到了这一点：</p><blockquote><p>Rule 6: <strong>Get up and running in 3 lines</strong><br>Excluding delegate methods, you should aim to make it usable at least for testing purposes with only 3 lines of code.<br>Those lines are:</p><blockquote><p>Instantiate it.<br>Basically configure, so it will show and/or do something.<br>Display or otherwise activate it.  </p></blockquote><p>That should be it. Anything substantially more onerous is a code smell.</p></blockquote></li></ul><ul><li><code>添加/删除书签和历史模块</code>，干掉，完全移入<code>DataSource</code>。并且前一版本是把数据序列化后保存为文件，这导致了相当大的性能问题，在暴力测试疯狂增删时甚至可能导致崩溃。新版中改为只保存必要的信息（比如起点和终点），等需要时再把路线实时计算出来即可。</li></ul><h2 id="一些私心"><a href="#一些私心" class="headerlink" title="一些私心"></a>一些私心</h2><p>上面基本把大块的重构页面讲完了，下面说几个旧版本中没有的页面，也算是我自己的私心。</p><p>考虑到这是我最后一次负责这个项目，也是第一次有如此大的决定权，我不禁在重构之余腾出手来加了一些自己想加的页面。</p><h3 id="致谢页面"><a href="#致谢页面" class="headerlink" title="致谢页面"></a>致谢页面</h3><p>作为一个有点情怀的程序员，我一直对于程序中没有对开源库的致谢这一点耿耿于怀。以前对项目没有话语权，也腾不出手做，这次怎么也得补上：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f80hpnui5cj20ku112dls.jpg" width="60%"></p><p>注：由于当时在发布时CocoaPods和Swift还有些兼容性问题，所以没有用CocoaPods自动生成的，而是自己写了个HTML网页。</p><h3 id="关于页"><a href="#关于页" class="headerlink" title="关于页"></a>关于页</h3><p>关于页也是夙愿之一。事实上更早的版本中有这个页面，但由于一些不可考的原因给砍掉了。</p><p>我仿照之前的关于页用Photoshop作了个图，并且顺便把以前版本的关于页也加了进来，往右边滑动即可看到。虽然这么个深藏在n级页面之下的页面估计没多少人点进来，但总算还是为以前那些已经离职的曾经为地铁通出过力的同事在这个角落立了个碑。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f80hpnqbusj20ku112juz.jpg" width="60%"></p><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p>这个点子我是在做好线路详情页的时候想到的：既然我做了一套可以在cell上画线路的代码，那么我可以把它复用到别的地方啊——比如整个地铁通的发展史！</p><p>于是就有了下面的页面：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79gw1f80hpoji3nj20ku112ah7.jpg" width="60%"></p><p>看起来很简单，其实做起来还是有点麻烦的。我在元旦跨年的时候去了趟日本休年假，途中带上了笔记本电脑，那真是一有时间就在做这个页面啊……</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7y52ic05dj21hc1z4x0s.jpg" alt=""></p><h3 id="末班车提示"><a href="#末班车提示" class="headerlink" title="末班车提示"></a>末班车提示</h3><p>这也是我私心特别想做的功能，也借着这次机会做了出来：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f80j8hcb9tj20ku1120vj.jpg" width="60%"></p><p>上个动图演示：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f80yq2elx9g20c80lrnpd.gif" alt=""></p><p>对于地铁线路而言，首班车很简单——只需从数据库中读取起点站的首班车信息即可。可末班车却复杂得多，它既不是简单的起点站末班车时间，也不是最后一个换乘站的末班车时间，而是有点类似于木桶原理，取决于短板——也就是说，取决于整条换乘路径中收班最早的换乘站。</p><p>在之前的版本中，我们实现了这个算法，但不时有用户表示疑惑：这个末班车是怎么算出来的？为什么这么诡异？</p><p>上面的这个功能就是对这个问题的优雅解答，一切都是自解释的：在用户操作的时候就能注意到变化，一句多余的说明都不用。</p><p>只要赶上标红字的站点的末班车，整条末班车线路就能成立。</p><p>事实上，之前的产品经理曾经做出过一版设计：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f810g7ergvj20hs0vkdil.jpg" width="60%"></p><p>我不喜欢这个设计，因为它割裂了上下文。弹窗是个十分影响交互体验的设计模式，除非你一定要显式地引起用户注意，否则引入弹窗就是错误的。电脑出栈入栈尚且有开销，何况人脑？（另外注意这个页面里的“首班车”和“末班车”按钮——没有比这俩按钮更突兀的设计了）</p><p>后来这个功能在反对声中索性被砍掉了，但我还是觉得这个需求是有必要的，只是需要找到更合理的设计。</p><p>在找到现在这个解决方案之前也纠结了很久，最终在某个凌晨能很快实现还是要归功于这次合理的架构设计，很难想象在之前那一坨3000行的代码里加个这种功能要抓狂到什么地步。</p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>是的，作为一个有着不止一点情怀的程序员……我还埋了个彩蛋，估计没人发现过，即使如此我也不想说xD</p><p>PS. 那些大公司的软件里彩蛋到底是怎么埋的？一Code Review不是就直接被辞退了吗？</p><h2 id="未竟事业"><a href="#未竟事业" class="headerlink" title="未竟事业"></a>未竟事业</h2><p>事实上，我还抽空稍微规划了一下iPad版本的地铁通：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f87g7fusumj21kw11xk57.jpg" alt=""></p><p>但由于时间实在是不够用，最终作罢。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>基本写完了程序主体，然后我又开始做起了市场。</p><p>当时赶工时每天唯一的娱乐是伴饭看一集《广告狂人》，所以到这个想广告词的环节觉得特别带感，感觉Don Draper（《广告狂人》男主角）上身。</p><p>于是就有了我用Photoshop做的下面这一批AppStore宣传图：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f811hg8q9kj21kw0k7dnk.jpg" alt=""></p><p>扶上驴，送一程。至此，对于这个项目，我的任务差不多完成了。</p><p>用户反馈差不多是这样：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f811mnjoolj20ku112wjk.jpg" width="60%"></p><p>就用项目刚开始时我在豆瓣发的一条广播来结束本文吧：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f811ovmy91j20ku112777.jpg" width="60%"></p><p>希望能给你带来一些启发，欢迎提出意见和批评。</p><p>感谢观赏。</p><hr><p>广告：</p><p>我现在正在找工作，希望加入一个比较大的团队继续学习。</p><p>如果您觉得我比较合适，可以联系：zshowing[at]gmail.com</p>]]></content>
    
    <summary type="html">
    
      在从TouchChina离职前，我决定完成一件一直想做却一直受制于进度与需求的事：将已经开发了三四年的地铁通进行一次彻底的重构。&lt;br&gt;本文从重构动机、重构思路以及重构后的对比几个角度，剖析了在程序开发以及架构设计中可能有所提高的地方。
    
    </summary>
    
      <category term="Code" scheme="http://zshowing.github.io/categories/Code/"/>
    
    
      <category term="iOS" scheme="http://zshowing.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://zshowing.github.io/tags/Swift/"/>
    
      <category term="产品设计" scheme="http://zshowing.github.io/tags/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="架构" scheme="http://zshowing.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Basic Loveology</title>
    <link href="http://zshowing.github.io/2016/08/11/Basic-Loveology/"/>
    <id>http://zshowing.github.io/2016/08/11/Basic-Loveology/</id>
    <published>2016-08-11T03:26:21.000Z</published>
    <updated>2016-09-25T03:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>*题目是致敬美剧&lt;Community>每集的标题命名风格。</em></p><p>我觉得，一段经得起推敲的感情，大致有两个分类。</p><p>一种是邂逅型，一种是养成型。</p><p>前者代表一类爱情电影：一次惊天地泣鬼神的邂逅，两个人发现他俩各种搭，究级搭，搭成狗，接下来就是各种无中生有的变故最后俩人没羞没臊地生活在一起。</p><p>后者代表另一类爱情电影：俩人最开始巨不搭，究级拧巴，拧巴成狗，接下来就是各种无中生有的变故最后俩人发现/变得还真挺搭的。</p><p>所有不属于这两类的都属于经不起推敲的感情，代表了剩下的爱情电影：莫名其妙的单恋啊，奇形怪状的多角恋啊，等等。</p><p>我在不同场合表达过许多次对相亲的反感和抵触，主要原因就是，我认为在现实中，邂逅型恋情的概率低到可以忽略。换句话说，参加1000次相亲大概才能有3次能碰到靠谱的人（3σ原则）。考虑到这世界上每天真实发生的总相亲次数和其中能产生的靠谱结果，我甚至觉得0.3%都是个乐观的估计。</p><p>相亲的结果几乎只有四种：一边试探着跟你交往一边暗暗觉得你是sb，或者一边试探着跟你交往然后突然发现你是sb，直接觉得你是sb，你觉得对方是sb。</p><p>所以，对于非男神女神级别的普通人而言，最现实，也是唯一可能走通感情线的途径，就是养成型路线。（注意，不是童养媳和光源氏计划。）</p><p>小学的青梅竹马，高中的前后桌，大学的同社团同学，公司里的程序员和产品经理。</p><p>只有他们有可能知道其实我一直是sb，然后还依然爱我啊。</p><p><br></p><p>但是说起来，比起普遍鄙视网恋的论调，我倒一直觉得在网上找对象比在现实中碰概率更靠谱。</p><p>不同于现实生活或者相亲时拘谨的找话题，网上生活是相对没限制的、兴趣导向型的。有人说网上代表着虚假和伪装，我反而认为网上才有一些当面看不到的真实。</p><p>尤其是豆瓣、微博这种积累着大量这个人历史偏好的天然数据库，比起相亲时互相刨根问底，效率高到不知哪里去了。</p><p><br></p><p>综上，如果不是运气爆棚碰到个青梅竹马或完美配对，在理论上最优化的找对象途径是：在网上广播出自己的信息和特性，由臭味相投的另一个个体接收，并发回反馈。</p><p>一直很奇怪豆瓣官方为什么不做这个，简直是浪费了大好的用户数据和刚性需求。</p><p><br></p><p>开始认真考虑在恰当的时候在网上也发个征友的帖子。虽然很不情愿高调，但没有一家合适的平台能让相关信息低调地精准抵达受众啊。</p><hr><p>参考资料：</p><p><a href="https://www.douban.com/doulist/37853447/">豆列：随手转发征婚交友帖</a><br><a href="https://www.douban.com/note/97560239/">《给未来的你》，2010/4/23</a></p>]]></content>
    
    <summary type="html">
    
      有关爱情的基本定理：一段经得起推敲的感情，大致有两个分类。
    
    </summary>
    
      <category term="理论" scheme="http://zshowing.github.io/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Love" scheme="http://zshowing.github.io/tags/Love/"/>
    
  </entry>
  
  <entry>
    <title>Advanced Self-Examination and Status Analyze</title>
    <link href="http://zshowing.github.io/2016/08/06/Advanced-Self-Examination-and-Status-Analyze/"/>
    <id>http://zshowing.github.io/2016/08/06/Advanced-Self-Examination-and-Status-Analyze/</id>
    <published>2016-08-05T17:01:53.000Z</published>
    <updated>2016-09-22T05:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>*题目是致敬美剧&lt;Community&gt;每集的标题命名风格。</em></p><p>回顾了一下之前的文字，上一次真正认真打些东西还是元旦跨年的时候，再早一些就要追溯到去年这个时候了。比起动不动就一个月加起来打几万字日志的大学时代，现在的我还真是惊人的沉默。</p><p>当年我说，我之所以喜欢码字，是因为谋篇布局这件事能让我快乐。</p><blockquote><p>“不管是写什么，也不管有没有人看，只要我可以遣词造句，只要我能够布局谋篇，我就能体会到那种不能言喻的快乐。至于得到了谁谁的认可，或是受到了某某的赞赏，那倒都是些锦上添花的东西了。”</p></blockquote><blockquote><p>“归根结底，写作，是因为快乐。仅此而已。”</p></blockquote><blockquote><p>——《因为快乐》，2009.4.30</p></blockquote><p>现在想起来，写作能让当时的我感到快乐，有几个原因：</p><ol><li>那是当时我发泄情绪的主要渠道；</li><li>不同于做数学作业和背电路公式，写作是一项创造性工作；</li><li>除了创造性以外，写作实质上是一件高度理性化的事情，这恰好有助于我整理混乱的大脑思绪；</li><li>最后一点是当时我没意识到，但是现在看起来显而易见的事情——写作恰好是当时的我最擅长的事情。</li></ol><p>而现在，处在2016年的这个十字路口，我再次拾起写作这个工具，主要是为了上述的第三个功能。</p><h2 id="The-Past"><a href="#The-Past" class="headerlink" title="The Past"></a>The Past</h2><p>实际上，上面说的第四点是一个贯穿我迄今为止人生的过程，我一直在寻找自己擅长的事情。有的时候这等同于另一个概念，就是上面所说，能让我感到快乐的事情。</p><p>由于这世上的选项实在太多，最开始我用的是排除法。</p><p>上大学之前我知道的是，我不喜欢做简单重复而没有创造性的工作，这是在我学车的时候看教练的工作状态领悟的。</p><p>后来进了大学，我意识到了另一件事：我不喜欢做看不到成果的理论工作。换句话说，我发现我是个实用主义者，只有那些能实实在在看得到的东西才能引起我的兴趣。（顺便，这大概是我在被数学分析的证明题折磨恶心的时候领悟到的。）</p><p>大四时因为一个偶然的契机，我开始为学校的BBS设计进站页面——说是设计，其实只是简单的摆弄Photoshop，做个700px × 400px的图片。但我立刻发现，从这件事情上，不管是过程还是结果，我都获得了不小的成就感。</p><p>毕业之后进入IT业界，我在完全没接触过手机开发的情况下在家自学了一阵，最终幸运地找到了个开发app的工作，因为比起传统的PC端编程（尤其是搞后端啊数据库神马的），手机app开发是典型的“能实实在在看得到的东西”。</p><p>在这期间，我又仔细界定了一下自己的兴趣所在：</p><ol><li>我喜欢做创造性的工作；</li><li>在1的基础上，我喜欢做能看得到“实体”的工作（在这个语境中，能看得到界面的就算实体）；</li><li>在1和2的基础上，我喜欢做能体现美感的工作；</li><li>最理想的（也就是说不现实的）状况是，我能胜任从头到尾（立项、画原型、写产品文档、做视觉设计、写代码、调交互、迭代）自己打磨一件，属于自己的产品。（顺便，今年前几个月我考虑过怎么才能做freelance，最终觉得确实不太现实）</li></ol><p>但实际情况是，即使做的是app开发，在很多时候还是广义的体力活的范畴。我能做的大概只有——在文档没说清楚的地方发挥自己的创意（换个大公司估计就不可能有这种事了）以及经常和产品经理探讨产品问题（以至于最后产品经理离职前还送了我一本<a href="https://book.douban.com/subject/25915629/">讲用户体验设计的书</a>。</p><h2 id="The-Present"><a href="#The-Present" class="headerlink" title="The Present"></a>The Present</h2><p>于是，就有了去学交互设计的想法。</p><p>留学这事大学时就考虑过，但是以当时的情况实在是不现实：数学分析和电路这种我毫无兴趣的理论课早已让我噤若寒蝉，我觉得即使出去也是大学几年惨痛经历的重演而已。况且要申奖学金必须申PhD，而如前所述，我对研究理论问题没有丝毫兴趣；如果只申Master的话——事实上，我爸说要卖一套房——把我吓坏了，本来就觉得自己会应付不来理论课，再加上这种败家的压力（简直就是必须要成功），简直想想就觉得透不过气。</p><p>现在的心态就要好很多，首先比起计算机科学，人机交互是个和蔼可亲得多的项目；至于关键的学费问题，现在作为一个有良好信用记录的人，我可以去银行申请贷款，甚至可以把前两年摇号中签后不得不买的车卖掉换个七手夏利扔小区里（反正即使我在北京也经常一个月不开）。再租个七平米的房子什么的省省钱（当年在上海住过半年多），应该差不多够用。所以，我对出国所有的恐惧中，就只剩语言和交流问题。这也是这次出国的想法一直拖到现在才真正论证可行性并付诸实践的原因之一。（另外的顾虑包括，GPA实在是比较渣，但翻阅知乎上这两年前辈的帖子有的说工作和项目经验可以弥补——感谢同为实用主义者的部分老美）</p><p>我只能这么想：比起在国内血汗工厂加班出卖代码劳动力来说，跟人用英语交流，甚至，做presentation也就显得不那么可怕了。</p><p>说完了“道”上的内容，说些“术”上的细节。</p><p>现实是这样的：</p><p>目前单词量还是非常贫瘠，而GRE的填空毫无逻辑难度，简直完全在考词汇量；</p><p>阅读速度非常差劲，建议15-17分钟完成的阅读，计时完成时间普遍在30分钟以上；</p><p>前几天试着看了一下&lt;Lord of the Flies&gt;，只读了4页，在Evernote里作了整整一页的笔记，花了一个小时；</p><p>基本上好的学校都要求托福口语和写作在25分以上，有些要求26分（年前考的时候口语20分，现在应该不会有什么变化——这也是在英国时airbnb的房东说我口语好，我十分惊讶的原因）；</p><p>我的背景（作品集相关）还需要强化，目前体现专业相关的内容太少；</p><p>学费还是需要再赚一赚……</p><h2 id="The-Future"><a href="#The-Future" class="headerlink" title="The Future"></a>The Future</h2><p>考虑到上面这些因素，赶今年申请季估计比较悬。</p><p>虽然HCI有着越来越热的趋势，但达不到硬性规定，申请也是没有意义的。</p><p>到现在居然卡在语言问题，实在是……但没办法，悟已往之不谏，知来者之可追。</p><p>所以还是继续再找个工作，然后在这多出来的一年里提升相关的水平。</p><p>——就算没申请成功（很有可能），至少英语水平还提高了呢，也算一举突破了一个长久以来的瓶颈。</p><p>反正我还能继续，骄傲（傲娇）地，写代码。</p>]]></content>
    
    <summary type="html">
    
      在2016年这个十字路口，回顾了一下历史的进程，激励了一下自我的奋斗。
    
    </summary>
    
      <category term="Life" scheme="http://zshowing.github.io/categories/Life/"/>
    
    
      <category term="Career" scheme="http://zshowing.github.io/tags/Career/"/>
    
      <category term="Life" scheme="http://zshowing.github.io/tags/Life/"/>
    
      <category term="自我剖析" scheme="http://zshowing.github.io/tags/%E8%87%AA%E6%88%91%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Simptrue企业VI视觉设计策划案</title>
    <link href="http://zshowing.github.io/2016/02/24/visual-design-for-Simptrue/"/>
    <id>http://zshowing.github.io/2016/02/24/visual-design-for-Simptrue/</id>
    <published>2016-02-24T02:49:49.000Z</published>
    <updated>2016-09-23T01:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Simptrue是一家致力于为企业提供数据分析商业服务的公司，理念是：Simple to use, true to your business.</p><p>由此可以提炼出主导整个设计的一些关键词：<strong>专业、信任、简洁</strong>。</p><p>在下面的设计中，我们将以这几个词为标准来考虑具体的做法。</p><h2 id="Logo"><a href="#Logo" class="headerlink" title="Logo"></a>Logo</h2><h3 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h3><p>Logo在设计过程中主要考虑如何与图表的意象结合起来，最初尝试的是块状阵列图，感觉与简洁的原则相悖。最终决定以字母“S”为原型，抽象成柱状图。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f82a9oqt7rj21kw11xatq.jpg" alt=""></p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>Logo，以及整体视觉形象设计的主色调定为蓝色，因为从颜色心理学的角度，蓝色是在第一时间最能给人信任、可靠感觉的颜色。</p><p>具体色值暂定为以下值，还有调整的余地。</p><p>目前定下一深一浅两种色调，分别用于各种适合的场合。</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f82gu9a14lj20ye04iq3g.jpg" alt=""></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>无衬线字体是现代字体发展的成果，非常适合公司简洁、现代、专业的企业定位，在浏览了字体集之后，最终选取了<code>Handel Gothic BT</code>这款字体。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82h2wpde8j21520qo45u.jpg" alt=""></p><p>这款字体除了满足无衬线的要求外，其设计思路非常严谨，在转角处几乎都是统一的几何弧度，整体非常符合公司的形象。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在确定了以上几个问题之后，接下来又进行了一些迭代。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f82h7rtok2j21kw37sqgg.jpg" width="60%"></p><p>最上面算是原型，下面主要是对柱状图的粗细进行了微调，并对右侧公司名进行了一下变化的尝试，最后互换了深浅颜色。</p><h3 id="定型"><a href="#定型" class="headerlink" title="定型"></a>定型</h3><p>下面分别是设计图、完成图和衍生图。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82hbspp6xj21kw0g4n7o.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f82hdfwyicj216s0uun17.jpg" alt=""></p><h2 id="衍生设计"><a href="#衍生设计" class="headerlink" title="衍生设计"></a>衍生设计</h2><p>以下设计作为对整体视觉设计的一些探索，供参考使用。</p><h3 id="名片"><a href="#名片" class="headerlink" title="名片"></a>名片</h3><p>名片的文字尝试了两种标志颜色的混合，实际使用中要先打印下，检查浅蓝的部分是否不易阅读。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f82hi5z3n8j21kw0h0n06.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82hi6l0j7j217w0r8wh3.jpg" alt=""><br>正面</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82hi6h5vdj217e0qkabb.jpg" alt=""><br>反面</p><h3 id="信纸"><a href="#信纸" class="headerlink" title="信纸"></a>信纸</h3><p>信纸的右下角尝试了对Logo元素的重复强化使用。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f82hk68hj0j21721k2q57.jpg" width="80%"></p><h3 id="报告书封面"><a href="#报告书封面" class="headerlink" title="报告书封面"></a>报告书封面</h3><p>这里尝试了两种配色的使用，并重复使用了柱状图这个意象。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82hm6avfpj20gj0nemza.jpg" width="60%"></p><p>这个版本中使用了构成Logo的三角形，和两个配色。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f82hmpg545j20gj0ne3zt.jpg" width="60%"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来这个方案败给了另外一个专业设计师的作品。那个朋友给我发来专业设计师的方案分享，差距确实很大。</p><p>主要的差距有两个方面：一是出各种原型的能力——我吭哧瘪肚半天也就这么一个主意，专业设计师一下给了一打供挑选；二是完成能力，虽然我在尽力进行模仿，但从实际成果来看还是图样。</p><p>这算是一个积累，继续加油。</p>]]></content>
    
    <summary type="html">
    
      Simptrue是一个朋友创业开办的公司，我参与了该公司Logo设计的竞标，这是设计过程。
    
    </summary>
    
      <category term="Design" scheme="http://zshowing.github.io/categories/Design/"/>
    
    
      <category term="Design" scheme="http://zshowing.github.io/tags/Design/"/>
    
      <category term="Logo" scheme="http://zshowing.github.io/tags/Logo/"/>
    
      <category term="视觉设计" scheme="http://zshowing.github.io/tags/%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>地铁通4.0发布</title>
    <link href="http://zshowing.github.io/2016/02/09/ChinaMetro-V-4-0-Released/"/>
    <id>http://zshowing.github.io/2016/02/09/ChinaMetro-V-4-0-Released/</id>
    <published>2016-02-09T12:02:28.000Z</published>
    <updated>2016-09-18T15:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>过去三个多月一直在做的项目AppStore审核通过了，我的感觉其实是做了一个自选题目的毕业设计。</p><p>从八月份开始萌生想法一步步执行到最后上线，除从头搭程序框架外还做了策划、设计、产品、文案的活儿（当然好多都是站在先贤的肩膀儿上），算是过了各种瘾。</p><p>出于私心还加上了致敬之前参与项目的同事的页面，虽然在关于页面的深处藏着，总算得上是力所能及的一点心意。</p><p>这次重写给了自己一次改正错误的机会，因为一个一线程序员在意识到他在架构上犯错的时候通常是没机会弥补的，只能默默记下来，而这是因为重写（注意不是重构）这件事通常对公司不构成合理的产值贡献。事实也确实如此，跑完完整测试流程的情况下，架构是否合理与用户关系不大，它影响到的是维护性和扩展性，这两点在这次项目的最后阶段有所体验，由于架构分得合理，紧耦合也按经验拆得差不多，最后关头才加的几个功能所需时间之少令我自己都瞠目结舌。</p><p>除此之外，这也可以算得上是一次社会公益活动，毕竟目前这个App的日活跃用户有大概几万，总用户数几百万，给他们留下一个漏洞百出的陈年老App，我是不太愿意的；尤其再说是我曾经写过这个App，我是不太甘心的。</p><p>当然，再剩下的就是上面提到的过瘾的机会，琢磨功能，打磨流程，憋宣传文案（带感的是我在同一时间里在补《广告狂人》，代入感非常强），用PS和AI作素材图和效果图等等，都我一个人来。其实由于我一直在过度乐观地估计工作量（最开始我甚至以为这事自己在私底下就能偷偷摸摸干完了），导致出去玩的时候我也带上了电脑赶工，但这也是一种过瘾啊——这不是在体验自由职业的生活么：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7y52ic05dj21hc1z4x0s.jpg" alt=""></p><p>最后，利用这次机会还从零掌握了一门语言Swift。</p><p>总之，几个月只看了两部电影，推了好多饭局，买了无数外卖，结果算是没白忙，看起来AppStore的反馈还算不错。一些细节因为实在没时间，有些疏漏，就要交给李叔来修了。</p><p>时间表复盘：</p><ul><li>2015.8 - 原始想法</li><li>2015.9 - 其他项目</li><li>2015.10.6 - Git Initial Commit，导入各种库，搜索Swift编码最佳实践</li><li>2015.10.19 - 正式开始编码工作</li><li>2015.11.23 - 将项目写进公司工作周报，李林超加入</li><li>2015.12.1 -<br>  <img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7y54u35oxj21kw0umgzk.jpg" alt=""></li><li>2015.12.11 - “12月21号提交”</li><li>2015.12.20 - 决定延期提交</li><li>2016.1.28 - 做完所有预期功能</li><li>2016.2.1 - 提交</li><li>2016.2.3 - The last day</li></ul>]]></content>
    
    <summary type="html">
    
      在地铁通4.0终于审核通过的时刻，回顾了过去几个月的经历。
    
    </summary>
    
      <category term="Code" scheme="http://zshowing.github.io/categories/Code/"/>
    
    
      <category term="Code" scheme="http://zshowing.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Bye, 2015</title>
    <link href="http://zshowing.github.io/2016/01/01/Summary-of-2015/"/>
    <id>http://zshowing.github.io/2016/01/01/Summary-of-2015/</id>
    <published>2015-12-31T16:21:30.000Z</published>
    <updated>2016-09-25T03:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻了半天微博和豆瓣的记录，终于想起来今年年初都在干什么了……</p><p><br></p><p>2015年大致分为3个阶段：</p><p>第一阶段是闲云野鹤般的第一季度，比如一月的观影量是奇迹般的29部，比如三月和四月几乎把公司图书室感兴趣的书都看完了，比如三月一个月没事儿闲的跑了98.7公里……</p><p>第二阶段是参与高中返校的筹备工作，真正投入这件事大概就是四月底五月初，当我意识到没人能接手做这件事的时候，只能硬着头皮上。没想到最后的结果算是相当不错，是一次偏离现有生活主线的歪打正着的难得收获，也结实了不少可靠的朋友。它直接增加了我心中往其他方向尝试的筹码。</p><p>之后的生活又闲散了一段时间，比如就在这期间我看了今年最爱的一系列电影：《小森林》，比如我把公司图书室剩下的感兴趣的书也读完了，比如我还去故宫看了个清明上河图……</p><p>第三阶段是App重写，日记显示是10月19日正式开始正经的coding，不过之前已经筹划一阵子了，是一个完全自己立项筹划推进的项目。因为突发的牙疼导致中间损失了好多天，到12月22日之前，除了看牙医之外的时间基本上全贡献给了这个项目，绝对废寝忘食。不过即使这样进度还是堪忧lol</p><p>“人呐，就都不知道，命运不可以预料”。在年初的时候，我绝对想象不到这一年会经历些什么，年末时会做出怎样的选择，现在会在哪里打下这些话。</p><p>觉得自己这一年做得还不错，两段忙的时间真的努力到每天没有休息的时候，现学现用Adobe Illustrator和SketchUp也很酸爽，相比主要在恢复元气的2014，是真正有点收获的一年。</p><p><br></p><p>2016年当然首先要把手头的项目发出去23333</p><p>然后要做什么呢？</p><p>I don’t know.</p><p>That’s the best part, right?</p><p>2016.1.1凌晨，<br>于日本东京·六本木 星巴克</p>]]></content>
    
    <summary type="html">
    
      一份来自日本东京的2015年度年终总结。
    
    </summary>
    
      <category term="总结" scheme="http://zshowing.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://zshowing.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Project RDFZ: The Documentary, Part II</title>
    <link href="http://zshowing.github.io/2015/09/27/Project-RDFZ-the-Documentary-Part-II/"/>
    <id>http://zshowing.github.io/2015/09/27/Project-RDFZ-the-Documentary-Part-II/</id>
    <published>2015-09-27T10:50:08.000Z</published>
    <updated>2016-09-25T03:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，这里是人大附中2005届学生毕业十周年返校活动的现场，我是记者小张儿。</p><p>接下来请您跟随我的镜头一起，深入到活动的各个环节。</p><p>首先映入我们眼帘的，是工人正在组装巨大的背板。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wqcs4v4oj21kw11xwxe.jpg" alt=""></p><p>在另一边，组委会的志愿者们正在用流水线的形式分装要送给到场同学的礼物。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wqei6flkj21kw2dcb0t.jpg" width="60%"></p><p>成果是这样的：</p><p><img src="https://mir-s3-cdn-cf.behance.net/project_modules/1400/d948cc29889607.5610054c31147.png" alt=""></p><p>大波同学还没到，工作人员还在待机：<br><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wr2iq5xrj21kw11xk72.jpg" alt=""></p><p>不知不觉中背板已经搭好了！大概是这样的画风：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7wql9tiy0j21kw11xnbx.jpg" alt=""></p><p>是大家的签到板和合影的背景板。</p><p>在大家忙着合影签名的时候，让我们四处走走，这是沿途的指示牌：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wqmeik77j21kw11xtoh.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wqnouxa7j21kw11xne8.jpg" alt=""></p><p>重头戏来了，在等候正式聚会开始前，组委会准备了收集印章活动，最先收集齐7个印章的同学可以<del>召唤神龙</del>获得神秘奖品。</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7wqqn5znbj21kw11x164.jpg" alt=""></p><p>那么印章的效果到底是什么样呢？</p><p>锵锵锵！！！</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7wqso6u29j21kw1kwttd.jpg" alt=""></p><p>还有还有，神秘礼物是什么呢？</p><p>你还别说，笔者也不知道！！</p><p><br></p><p>活动正式开始：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wqxe0om1j21kw11xwsf.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wqwqa6v5j21kw11xe2l.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wqz2hgb9j21kw11x7ki.jpg" alt=""></p><p>活动圆满结束！部分筹备组人员合影：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wr8wc5foj20zk0non1v.jpg" alt=""></p><p>到家，终于见到了冰箱贴的真身：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wqv9muvaj21kw11xwsk.jpg" alt=""></p><p>就是这样，感谢观赏！</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wr7d4gkmj21kw2dctme.jpg" alt=""></p><p>文字/摄影：Jon Showing</p>]]></content>
    
    <summary type="html">
    
      在高中毕业十周年返校聚会即将到来的时候，我临危受命被抓来设计与之相关的一系列物料。&lt;br&gt;这是对整个设计过程进行记录的系列文章之二，描绘了活动现场的设计实物效果。
    
    </summary>
    
      <category term="Design" scheme="http://zshowing.github.io/categories/Design/"/>
    
    
      <category term="RDFZ" scheme="http://zshowing.github.io/tags/RDFZ/"/>
    
      <category term="Design" scheme="http://zshowing.github.io/tags/Design/"/>
    
      <category term="Logo" scheme="http://zshowing.github.io/tags/Logo/"/>
    
      <category term="视觉设计" scheme="http://zshowing.github.io/tags/%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Project RDFZ: The Documentary, Part I</title>
    <link href="http://zshowing.github.io/2015/09/26/Project-RDFZ-The-Documentary-Part-I/"/>
    <id>http://zshowing.github.io/2015/09/26/Project-RDFZ-The-Documentary-Part-I/</id>
    <published>2015-09-26T10:50:08.000Z</published>
    <updated>2016-09-25T03:08:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>本着没有总结就没有进步的原则，早就想写这么一篇了（咱能不每篇都用这句话开篇么……）。嗯，接下来就是给今年十周年返校聚会做设计的一些记录。</p><p>题目来自于素材文件的文件夹名。在我的Evernote里面还有好多其他Project XXX，这种命名方式感觉是被日本人带坏了……</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>被拉进这次活动的契机非常神奇，大概是2014年底的某天（手机恢复了一次系统，微信记录已散佚），陈培同学找到我说明年有个毕业十周年的返校活动，能不能来帮忙，于是我就在懵懂中被拉进了一个大群。</p><p>而我和拉我进群的陈培同学在这时连见都还没见过，属于当年人人网误打误撞加的网友！甚至连网友都不属于很熟的那种！</p><p>2015年3月15号第一次在高中楼开会的时候，我对自己的定位还停留在海报设计师和摄影师的水平上，总想着应该还能找到更专业的人来干这事儿吧？</p><p>我意识到没有什么救世主也不靠神仙皇帝是在五月中旬。实际上，四月底的时候我还用2004届的Logo改了一份交了上去：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7vvqt8lhvj20go0g741g.jpg" alt=""></p><p>没错，你们所有的照片和纪念品上的logo，险些就是这个样子……</p><p>5月底是第一份设计——邀请函截稿的日子，而要出邀请函的设计稿，必须搞定logo。当我意识到我不能交出这么个东西然后对别人说我负责了这次的设计的时候，我念了两句诗：</p><blockquote><p>这几天突然就发现要做的事情都赶到一块儿了……想起句非常喜欢的台词”With great power comes great responsibility”，虽然不喜欢《xx侠》类电影，但是这句台词真是从第一次听见就觉得很有道理。觉得累的时候有时就会用这话来洗脑打鸡血。<br>2015-5-20 08:16 来自 微博 weibo.com</p></blockquote><p>第一次系统的设计工作，开始了。</p><h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><p>我咨询了公司的美女设计师小英姐，她推荐给我一个网站<a href="https://www.behance.net/">https://www.behance.net/</a> 经过一番钻研，我发现类似的成套的设计其实都可以分解成一系列按部就班的步骤。比如先确定一些独特的设计元素，或者先定下Logo，然后剩下的内容就比较好办了，往其他的设计内容上合理套用即可。</p><p>这是当时我在豆瓣发的心得：</p><blockquote><p>Showing V1.2 说:<br>从小一直对做原创工作的人很敬畏，也很想成为其中的一员，不过一直不太有信心。前一阵考察了不少设计，发现其实设计工作是一项系统工程，可以分解为无数不那么原创的步骤，但最终的效果依然非常惊人。又想起人们说的写小说的套路，大概世界上的创造性工作互相之间都有相通之处。哪怕是编程。<br>2015年5月24日</p></blockquote><p>所以，我要面对的第一个，可能也是最大的挑战，就是重新设计一个合适的Logo。</p><h3 id="Logo"><a href="#Logo" class="headerlink" title="Logo"></a>Logo</h3><p>它必须简洁，以便方便地复用在其他设计上，同时又必须显眼，让人一看就知道这个Logo描绘的是人大附中，不是别的什么。</p><p>最重要的，就是如上所说的，是它将为所有后续的设计打下一个可供发挥的基调。</p><p>像所有伟大的设计一样，这个设计的最初构思是描绘在<del>餐巾纸</del>日历上的。</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7vvudjo45j20zk0qoaf8.jpg" alt=""></p><p>然后细化成了这样：</p><p><img src="https://mir-s3-cdn-cf.behance.net/project_modules/1400/4751e129889607.560ebf094f91f.png" alt=""></p><p>如图，备选方案主要就是校门和校服。基本上，2004届的logo中已经把所有的标志性物体都堆进去了，而我要做的，是减法。</p><p>可能有读者不知道这里面提到的校门是什么样子，就是下面这张照片的样子：</p><p><img src="https://mir-s3-cdn-cf.behance.net/project_modules/1400/f06f3029889607.560ebf094c023.jpg" alt=""></p><p>随后我下载了之前只用过几分钟的AI，进行了第一波尝试：</p><p><img src="https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/5d11e929889607.560ebf094d196.png" alt=""></p><p>以及：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7vwy4f7n6j21kw16oafl.jpg" alt=""></p><p>由于实在不认识什么设计界的人，我在微信上进行了无差别骚扰，因为聊天记录丢失，大部分的反馈已经记不清了，印象最深的是hww同学的反馈，她说字体实在是应该好好换一下，这和后面几天小英姐对请柬的评价如出一辙，包括第一版邀请函完成后发到微博，@洞悉帝 和zf同学也都有此反馈，让我一下子意识到自己对字体的敏感度有短板。</p><p>由于进度紧张，加上我认为把Logo放到上下文中会有助于决断，所以我在同时进行邀请函的设计。</p><p>我做出的第一版邀请函是这样的：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7vvzz9rghj20gj0nedg1.jpg" alt=""></p><p>可以看到已经很接近最终版本了。而这时小英姐给我看了她百忙之中帮忙做的版本：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7vw0w6gkgj20go0ovjs1.jpg" alt=""></p><p>跟专业的一比，一下找到了差距有没有……</p><p>小英姐对校门进行了修改，但是我权衡之下还是觉得未修改的版本对校友来说更打眼。有“10”这个寓意固然好，但为了凑出这个寓意把原有的形状模糊了就有点得不偿失。何况，我还是很喜欢“十”和校门边缘交叉的处理。</p><p>所以接下来主要的问题就是字体。这时小英姐设计中用到的字体给了我很大的灵感，她在其中用到了造字工房的郎宋体：<br><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7vw36v6fij20go0goq3h.jpg" alt=""></p><p>在此感谢造字工房对此款字体的非商业使用开放了授权。</p><p>这款字体的特点是竖笔粗，横笔细，我一下想到，这恰好与校门的形状可以对应！</p><p>经过一番调整，校门的形状大致确定，与文字搭配完美，但是又发现郎宋体的数字和英文相对而言达不到要求，需要另外找合适的字体。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7vw4o6dmcj209r058aaf.jpg" alt=""></p><p>幸好公司会议室的书架上有一本<a href="https://book.douban.com/subject/4085474/">《1000 Fonts》</a>，我拿来从头翻到尾，以纵向宽横向细为目标，找到了两款：Sardonyx和Serpentine。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7vwh1uqwnj20go0ciq6d.jpg" alt=""></p><p>经过对比和调整，最终使用的是Sardonyx的横向拉伸方案。最终完成体：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7vwhn95waj218g0b4tae.jpg" alt=""></p><blockquote><p>中文字体: 造字工房 郎宋<br>英文/数字字体: Sardonyx bold</p></blockquote><p>Logo搞定以后，一套设计就有了设计的基本元素，下面的事情就好办多了。</p><h3 id="邀请函"><a href="#邀请函" class="headerlink" title="邀请函"></a>邀请函</h3><p>有了Logo，邀请函基本上只是在上面的设计图基础上把Logo套用进去即可。</p><p>我在6月12号的一次进度碰头会上第一次看到了邀请函的实体印制版本，当时很震惊在屏幕上看起来有些平淡的设计图一旦有了手感或者质感，居然会是完全另一种感觉：</p><p><img src="http://ww4.sinaimg.cn/mw690/5613ec79jw1f7wgiqtd7mj20hs0dcab7.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/mw690/5613ec79jw1f7wgebwnlej21kw16ok5j.jpg" alt=""></p><p>这是继上次给徐经理印制送别明信片之后，又一次对“质感”这件事有所感悟。</p><p>在这次碰头会上，也定下了聚会需要的物料，除了工作组需要的背板工作牌等东西之外，重头戏是给返校同学的礼物——对我来说，就是下一阶段的设计任务。</p><p>一个是明信片，一个是在明信片上盖的印章，还有就是冰箱贴。</p><p>插播当时我在豆瓣发的广播：</p><blockquote><p>Showing V1.2 说:<br>虽然做校友返校聚会设计这事儿实情是实在找不到人我才顶上去的，但还是有种花大家的钱过自己的设计瘾的感觉……<br>最头疼的是找不到人来讨论问题，好像认识的人找不到搞艺术的……<br>2015年6月17日</p></blockquote><h3 id="冰箱贴"><a href="#冰箱贴" class="headerlink" title="冰箱贴"></a>冰箱贴</h3><p>冰箱贴是一波主打纪念品，非常重要。事实上在这个事情上我有个多年前的储备，就是在大学时拿高中楼道里的柜子作为原型练手做的一张图：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wpde7r7gj20l40ci76d.jpg" width="60%"></p><p>我十分想把它变成实物，也就是说，在家里的冰箱上复刻出高中楼道的感觉。</p><p>我甚至做了效果图：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wpfy2cdrj20xc0m8dpv.jpg" alt=""></p><p>但是在和总舵主（本次返校活动的总协调人）进行沟通时，她反馈说作为纪念品应该多少喜庆一点，这个方案虽然创意很好却不太搭。</p><p>我想了想，觉得还是很有道理的，于是改成了正统的冰箱贴设计：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wpjuxkqvj21a21a27ar.jpg" width="40%"></p><p>后来事实证明，这个选择还是正确的。</p><h3 id="明信片"><a href="#明信片" class="headerlink" title="明信片"></a>明信片</h3><p>有了上一次制作明信片的经验，加上这么多年基本都在做伪平面设计，这次对于明信片的设计任务我心里还算比较有底。按照习惯，最先进行的工作是：建立素材库。</p><h4 id="建立素材库"><a href="#建立素材库" class="headerlink" title="建立素材库"></a>建立素材库</h4><p><img src="http://ww4.sinaimg.cn/large/5613ec79jw1f7wjrxxrylj21kw114wvp.jpg" alt=""></p><p>这个阶段将进行大量的搜索工作，换用各种关键词在flickr、tumblr、新浪微博和Google等处花式收集。当然，也包括自己这么多年在硬盘里持续的存货。（说实话，到这时我简直觉得这事除了我之外没几个人能干好。兵马未动，粮草先行啊！）</p><h4 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h4><p>接下来，要从素材库中选取若干有代表性的角度。说实话，真正的设计流程应该是先设计角度再去现场拍照——但我限于时间精力和不能随便进校园的实际情况，只能采取这种折中方案。</p><p>选题的原则大致是：有代表性，尽量分散，类似素材想办法合并，以最大化利用。</p><h4 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h4><p>大致如此（工作照摆拍）：</p><p><img src="http://ww3.sinaimg.cn/mw690/5613ec79jw1f7wk8b8aquj21kw11xwux.jpg" alt=""></p><h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><p><img src="http://ww2.sinaimg.cn/mw690/5613ec79jw1f7wk8izla9j218g121nih.jpg" alt=""></p><h3 id="背板及指路板"><a href="#背板及指路板" class="headerlink" title="背板及指路板"></a>背板及指路板</h3><p>活动当天的背板和引导用的指路板，当时后勤组要得很急，不过这个相对来说就好办很多，再次印证了有了Logo一切都顺其自然这一点。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7vx8emdo6j21kw0sgjvf.jpg" alt=""></p><p>6月21日完成。</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f7wos6mipnj218g0stdkf.jpg" alt=""></p><p>6月23日完成。</p><h3 id="胸牌"><a href="#胸牌" class="headerlink" title="胸牌"></a>胸牌</h3><p>胸牌也是简单的基于现有元素的组合，不需太复杂就能很舒服：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f7wp34zfdoj20j60b4aaz.jpg" alt=""></p><p>6月24日凌晨完成。</p><h3 id="印章"><a href="#印章" class="headerlink" title="印章"></a>印章</h3><p>印章的设计是这次除了Logo之外挑战最大的部分，因为它不仅数量多（7个），而且没法像明信片那样<del>偷懒</del>找素材，只能自己手绘。</p><p>好在我在之前设计Logo的时候已经稍微摸清了一点Illustrator的门道，接下来现学现卖也算稍微有点底。</p><p>第一步依然是收集素材，只不过这回是作为绘图的参照。</p><p>草图：</p><p><img src="https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/48775729889607.5610dd307ae12.png" alt=""></p><h4 id="6月24日"><a href="#6月24日" class="headerlink" title="6月24日"></a>6月24日</h4><p>6月24日，前两个印章完成：</p><blockquote></blockquote><p>Showing V1.2 说:<br>印章系列(完成度2/7)。PS. 有还上豆瓣的高中校友吗？虽然不是什么好设计但是在返校活动前看到还是请保密啊……<br>2015-06-24 01:37:51</p><p><img src="http://ww4.sinaimg.cn/mw690/5613ec79jw1f7wn1wt96lj21kw143guu.jpg" width="70%"></p><p><img src="http://ww1.sinaimg.cn/large/5613ec79gw1f7wp06k8z5j20d209ndi7.jpg" alt=""></p><p>高中楼，完全在AI里面照着照片描的；</p><p><img src="http://ww3.sinaimg.cn/mw690/5613ec79gw1f7wn4azp7sj21kw22pha1.jpg" width="70%"></p><p>综合楼，上面的形状是餐盘，因为这楼下面两层都是食堂，最上面是阶梯礼堂。在描绘时使用了AI的透视模式。</p><p>字体与Logo保持一致，使用郎宋体。</p><h4 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h4><p><img src="http://ww1.sinaimg.cn/large/5613ec79gw1f7wnabiyv7j20t20h4dkc.jpg" width="70%"></p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7wozgygfmj20hm08vdja.jpg" alt=""></p><p>以及：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79jw1f7wndgakynj20t110t7b5.jpg" width="70%"></p><p><img src="http://ww2.sinaimg.cn/large/5613ec79gw1f7woxt5uj4j20hx0b70v2.jpg" alt=""></p><h4 id="6月26日"><a href="#6月26日" class="headerlink" title="6月26日"></a>6月26日</h4><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7wnodm9p4j20so0lg41g.jpg" width="70%"></p><p><img src="http://ww2.sinaimg.cn/large/5613ec79gw1f7woz3glpqj20h30cpac0.jpg" alt=""></p><p>以及：</p><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7wnnnd61tj20sr0kc0wr.jpg" width="70%"></p><p>而最后一个印章也在制作中：<br><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f7wnq9k6rzj20sz0tawhz.jpg" width="70%"></p><p>工作照：</p><p><img src="http://ww1.sinaimg.cn/mw690/5613ec79jw1f7wnz4kd91j20zk0qo0yh.jpg" alt=""></p><p>继现学AI之后又开始现学SketchUp xD</p><h4 id="6月27日"><a href="#6月27日" class="headerlink" title="6月27日"></a>6月27日</h4><p><img src="http://ww2.sinaimg.cn/large/5613ec79jw1f7wo0r07hoj21kw0y0qd6.jpg" width="70%"></p><p>至于最终印出来的样子是什么样呢？依然延续了“成品让人惊叹”的定律，请继续阅读下一篇。</p><p>至此，轰轰烈烈的巨型设计现场进行了一个多月终于告一段落，距离真正的活动也进入了最后一周倒计时。</p>]]></content>
    
    <summary type="html">
    
      在高中毕业十周年返校聚会即将到来的时候，我临危受命被抓来设计与之相关的一系列物料。&lt;br&gt;这是对整个设计过程进行记录的系列文章之一，记述了一次完整的设计流程。
    
    </summary>
    
      <category term="Design" scheme="http://zshowing.github.io/categories/Design/"/>
    
    
      <category term="Design" scheme="http://zshowing.github.io/tags/Design/"/>
    
      <category term="Logo" scheme="http://zshowing.github.io/tags/Logo/"/>
    
      <category term="视觉设计" scheme="http://zshowing.github.io/tags/%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Photoshop" scheme="http://zshowing.github.io/tags/Photoshop/"/>
    
      <category term="SketchUp" scheme="http://zshowing.github.io/tags/SketchUp/"/>
    
      <category term="Illustrator" scheme="http://zshowing.github.io/tags/Illustrator/"/>
    
  </entry>
  
  <entry>
    <title>那些女孩教我的事</title>
    <link href="http://zshowing.github.io/2015/07/27/lessons-that-girls-taught-me/"/>
    <id>http://zshowing.github.io/2015/07/27/lessons-that-girls-taught-me/</id>
    <published>2015-07-27T10:55:56.000Z</published>
    <updated>2016-09-25T03:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是个早就想写但一直不知怎么下笔的题目，记得不久前曾经努力开过一个头，刚才找了一下，发现正好是半，年，前……</p><p>题目出自胖哥当年在KTV特别爱点的一首歌，但严格说来要写的内容基本上还是自己悟出来的。</p><p>之前迟迟下不了笔的原因在于，这篇跨度从小学到现在的东西线索过于庞杂，又不想写成流水账。</p><p>而现在匆匆下笔的原因则是，我急需跟自己讲明白道理。</p><p>想来想去，还是分成几个“Before&amp;After”比较清楚。</p><h3 id="颜控去死"><a href="#颜控去死" class="headerlink" title="颜控去死"></a>颜控去死</h3><p>说起来，我最为彻底的进步就是认清了这件事：你不能仅仅因为一个女生漂亮就爱上她。</p><p>说起来轻巧，实际上这却在很大程度上是在挑战一个人的本能。</p><p>君不见各国的爱情片里，充斥着类似的所谓一见钟情桥段？</p><p>总结起来，这件事发生的年代基本上是在心智尚未成熟的年代，比如小学、初中（以至于后来我不认为初中有过真正喜欢过谁）、高中刚开始。最后的一个事例大概是大学时的小师妹事件。</p><p>意识到这么做不对也不是件很难的事情，只需要有过几次失败自然能想明白。到后来我对于这点认识得越来越清楚，比如大学时的小慢，比如公司里的湖南妞儿，比如在HIMYM完结活动中偶然认识的小美女，都严格恪守了这条规则，没有让内心有更多的波动。</p><h3 id="谢绝杀熟"><a href="#谢绝杀熟" class="headerlink" title="谢绝杀熟"></a>谢绝杀熟</h3><p>一句话，你不能因为和一个人很熟，就任性到非要和她在一起。</p><p>托班里女生质量比较高的福，在漫长的岁月里，我几乎在不同的时间段里爱上了所有的熟人。指特别熟的那种。幸好，最后我只搞砸了一次，其余的全被我权衡后花几个月时间克制住了，可喜可贺。当然，如果在美剧里这可能不算什么= =</p><p>显然，我证明了“熟”和“在一起”不是充要条件。应该说，两者不管从谁都推不出对方。</p><h3 id="聊得来？再想想？"><a href="#聊得来？再想想？" class="headerlink" title="聊得来？再想想？"></a>聊得来？再想想？</h3><p>目前为止最有欺骗性的特质就是所谓“聊得来”。</p><p>这里所说的“欺骗性”，不是指女生故意欺骗，而是你很难意识到在你们看起来巨聊得来的背后，是什么在支撑。</p><p>有的女生，天生话痨。她跟你聊得来没错，她也和剩下的中国人聊得来。她还和部分英语国家的人聊得来，取决于她的英文水平。</p><p>有的女生，在和你聊得来的表象下，其实有着一种让对话进行下去的使命感。一旦她失去了这种动力，你会发现你们之间其实无话可说。</p><p>你还可以举一反三。总之，如果你没有注意到这些现象背后的本质，你会陷得非常深，你甚至会抑郁——因为你会觉得，你无力改变你遇到的事情。然后你会发现，这不是认知偏差，这是真的。</p><h3 id="感动是无法复制的"><a href="#感动是无法复制的" class="headerlink" title="感动是无法复制的"></a>感动是无法复制的</h3><p>我觉得有必要把这一点单提出来，因为在当下非常有现实意义。</p><p>曾经遇到过一些非常非常非常非常让我感动的事情，感动到险些去追给我带来这份感动的女生。</p><p>幸亏没有。</p><p>如果你稍微有点思考能力就会明白，一天天的生活不是靠感动来感动去继续下去的。</p><p>诚然，做出让你感动的事情说明她有一颗金子般的心。</p><p>然并卵好吗！！</p><p>这与能让你们的关系发展下去，相关系数无限近似于零。</p><h3 id="事件是无法复制的"><a href="#事件是无法复制的" class="headerlink" title="事件是无法复制的"></a>事件是无法复制的</h3><p>而另外一些时候，你不是被打动，而是经历了一些你从来没有跟女孩子一起经历过的事件。</p><p>比如某年暑假，跟A同学，从附中的操场翻窗户进到高中楼，像特工一样避开高中楼保安；<br>比如某年春天，跟B同学见面时，超偶然地一起玩了个公园里的刺激性游乐项目；<br>比如前一阵，在一个聚餐里，我去敬C同学表示感谢时，她反而一边和我说话一边哭得梨花带雨……这也是我必须要写这篇东西的原因。（必须说，这件事同时也符合上一条，我被感动得一塌糊涂）</p><p>麻省跳大神学院的占卜研究表明，只有智商低于27.5的物种，才会把偶然发生的事件，当成必然发生。</p><p>你被这些事件震撼，唯一能得出的结论是，你经历得太少。仅此而已。End of story.</p><h3 id="Be-Attractive"><a href="#Be-Attractive" class="headerlink" title="Be Attractive"></a>Be Attractive</h3><p>说了一大堆Don’ts，有没有什么Do呢？</p><p>上面写的这一点就是我意识到的最大的To do. 来自zf同学在某一年的微博评论。</p><p>神奇的是，当时我居然对这个评论还没当回事，这是直到后来我又经历了一些事情，再翻到时才惊讶地发现的。</p><p>原话差不多是：</p><blockquote><p>“不要总想着useful啊，要想想怎么让自己attractive啊！”</p></blockquote><p>这大概是我最难改的顽疾了，直到现在我有时还忍不住会去想自己有什么用，能怎么帮到对方。</p><p>吴彦祖能怎么帮到你了？</p><p>圆通快递的取件小哥倒是能天天帮你。</p><p>哦，热心的水管工东尼大木老师也可以。</p><h3 id="女生不是追来的"><a href="#女生不是追来的" class="headerlink" title="女生不是追来的"></a>女生不是追来的</h3><p>曾经特别不理解“追”和“表白”这两种行为。</p><p>上面说到useful，其实追的本质就是个展示自己用处的过程。</p><p>你把姿态放得很低，“我能陪你！我能给你买早餐！我还能带你去看这个世界！”</p><p>谁不能啊？</p><p>表白就更可笑了，我一直对一个场景脑补不能，就是女神在某天答应了穷追良久的屌丝的表白，接下来这俩人能怎么相处。</p><p>描绘屌丝追女神的殿堂级作品《I’’S》，对此的处理办法是：留白。</p><p>绝妙的处理办法啊！！反正我当时特别激动地觉得终于可以解惑了，结果是硬生生地给作者行了个跪拜大礼。</p><p>直到大学时有一天看BBS的帖子，有人说，表白这事其实应该就是个过场，至少也是要到有九成把握了再干。</p><p>顿悟。我一下子觉得，这样整个过程就都讲得通了。</p><p>强行表白基本上是要给自己找个交待的那种，属于自杀性爆炸范畴。</p><p>武断一点的说，女生不是追来的，你只是让她确认心里的不确定，仅此而已。</p><p>这是至今依然总也记不住的一件事情。</p><h3 id="性格，性格，还是性格"><a href="#性格，性格，还是性格" class="headerlink" title="性格，性格，还是性格"></a>性格，性格，还是性格</h3><p>总结一下，到现在，有一点基本是肯定的，就是两个人是不是适合在一起，性格，或者气场，或者whatever类似的东西，是决定性因素之一。</p><p>所以对于男生来说，实际上自身的素质决定了选择面的宽窄。你的性格越多样，就越能和越多类型的姑娘搭。</p><p>像我这样的闷骚型，就无悬念的一定要找自带话题少女。</p><p>伤感，但没办法，这个世界就是这样。</p><p>“出场自带500多斤的伤感”。</p><h3 id="没有一个帝国是靠谦卑维持的"><a href="#没有一个帝国是靠谦卑维持的" class="headerlink" title="没有一个帝国是靠谦卑维持的"></a>没有一个帝国是靠谦卑维持的</h3><p>2013年9月，我借着给HIMYM第八季写影评的借口，狠狠地抒发了一下自身的思考结果。</p><p>我写道：</p><blockquote><p>“Ted比我强的最关键的一点就在于，在对孩儿他妈的长期寻找中，他一直在使自己变得更强大，变得更吸引人。他会滔滔不绝地与你谈论他喜爱的领域，会去做各种看起来很傻但是很有意思的事情，同时，不放弃自己即将遇到小黄伞的信念（虽然一直拿着本《霍乱时期的爱情》在地铁上看这种钓鱼行为令人非常Orz）。 </p></blockquote><blockquote><p>只有这样，在真正遇到“老妈”的时候，你才能让她感到开心，你的光辉才能让她也彻底爱上你。所谓的命中注定，无非是实力超群——至少是实力相当。 </p></blockquote><blockquote><p>没有一个帝国是靠谦卑维持的。感情也一样。 ”</p></blockquote><p>一段现在看来依然带着寒光的文字。</p><p>2015年7月，依然倒在了同一段文字前面。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>之前和朋友说过，经过我对自身经历的仔细思考，如果仅仅从性格上讲，和我最搭的是D同学。</p><p>相处模式是这样的：她给我讲故事的时候，我吐槽。她不讲故事的时候，我就逗闷子。</p><p>我还知道哪些点会“激怒”她，我会没事闲的故意往这个点上引。北京话里这叫贱招儿。</p><p>得到的反馈是胳膊上的一顿猛掐。</p><p>经常是一节课下来，累倒是不累，反而笑得肚子疼。我外加胳膊疼。</p><p>如果我至今还残存一些逗闷子的能力的话，大概有八成是那个时候养成的。</p><p>这种相处模式并不新奇，但如果放在这十几年在和女生交往中长期的暗色调经历里面，这几乎是其中唯一的一抹亮色。</p><p>所以，它一定有一些特别的地方。</p><p>分析了一下，首先，在异性朋友里面，她是和我关系最好的人里面唯一一个特别外向的；其次，我并没有爱她，因此，我完全不必顾忌自己的形象（其他经历中我都是小心翼翼）；另外，我们没有一方明显弱势，基本势均力敌；最后，我们都很看重对方这个朋友。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我一直觉得，人总是要长点记性的。</p><p>我喜欢写文章总结东西，因为除了写诗之外，写作其实是一件非常需要理性的事情。在你心乱如麻，脑中充斥着万千种想法的时候，只要你能坐下来把你的问题像模像样地筹划成一篇文章写下来，一般情况下就能好很多。</p><p>而近几年，这个大杀器的使用频率是眼看着越来越少。</p><p>这篇文章之所以早就想写，是因为我一直想整理一下到目前为止遇到的事情，以便提醒自己不要重蹈覆辙。毕竟很多时候，这里面列出的反例并不是那么显而易见，甚至需要挑战人性。</p><p>所谓的Perfect Match也许根本不会遇到，但能长期相处的人基本上还是应该有个baseline的。</p><ul><li>一个真心欣赏你的人。</li><li>一个至少在和你说话时自带话题的少女。</li><li>一个既不会强势也不会弱势的朋友。</li></ul><p>&lt;Juno&gt;里面有一首歌，里面有这么一句，给我留下了极深的印象：</p><blockquote><p>“You’re a part-time lover and a full-time friend.”</p></blockquote><p>差不多就是这样。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来一直觉得自己的经历非常苍白，但总结下来居然觉得自己要赶上Ted了……</p><p>说起来，虽然前面说了好多“暗色调”的事情，但总体上，我还是非常感激生命中的那些过客。<br>不只是因为我自己也是过客，而是，刚才我在翻之前写的东西的时候，看到了这么一句：</p><blockquote><p>2013-02-28 14:33:22 《两年》<br>无论如何，我要感谢。我险些忘记，我还能如此开心。</p></blockquote><p>生命，就是这样才井猜的啊。</p><p>说到Ted，我觉得在影视作品里我几乎找不到比他更像我的人了。</p><p>今后，我也特想偷他的这句话：</p><blockquote><p>Kids,<br>This is how I met your mother.</p></blockquote><p>2015.7.26 凌晨 初稿<br>2015.7.27 白天 续完并改二稿<br>2015.7.29 深夜 补充“女生不是追来的”一段</p>]]></content>
    
    <summary type="html">
    
      这篇文章总结了前二十几年在和女孩的交往中所积累的人生经验。&lt;br&gt;Kids, this is how I met your mother.
    
    </summary>
    
      <category term="理论" scheme="http://zshowing.github.io/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Love" scheme="http://zshowing.github.io/tags/Love/"/>
    
  </entry>
  
  <entry>
    <title>Superfly - My Best Of My Life</title>
    <link href="http://zshowing.github.io/2015/05/28/Superfly-My-Best-Of-My-Life/"/>
    <id>http://zshowing.github.io/2015/05/28/Superfly-My-Best-Of-My-Life/</id>
    <published>2015-05-27T17:20:10.000Z</published>
    <updated>2016-09-18T15:33:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>那天傍晚，天已擦黑却又泛着神奇的亮蓝色，我骑车飞驰在路上，脑子里蹦出的是这首歌的前奏。<br>如果你听过这首歌，你就知道这是件顺理成章的事情——每次《Boss》那部剧演到最后这首歌响起的时候，我脑子里就会脑补出傍晚的亮蓝色。</p><p>然而我要说的不是这个。</p><p>最近因为机缘巧合，经常想起500多天前那段时间。</p><p>在一篇2013年11月4日的<a href="http://spacesoaring.blogbus.com/logs/236796474.html">blog</a>里，我写道：</p><blockquote><p>我面对的是26年来最让自己不满意的一个自己。</p></blockquote><p>那时的我不仅是不满意，而且是束手无策，坐以待毙，疾病缠身，还正赶上公司有个大新闻……啊是大项目，周末加班，平时时不时地还得在家继续在dropbox同步过来的工程上工作到凌晨去，盆友们，女四们，先生们，全果过族人民，这是闷声大作死的节奏。</p><p>那篇blog的最后我是这么写的：</p><blockquote><p>其实现在最想恢复的是，那种喷薄的创造力，好久都没有创造过什么人世间不存在的东西出来了。</p></blockquote><p>通常在那种境况下的心理活动才最纯粹和真实，把这篇blog淡忘许久之后再回过头来看，我才发现我一直在追求，也最给我满足感的，正是这种创造感。</p><p>然而我也暂时不想说这个。</p><p>我想说的是，今天好几个人通过各种方式发来滋瓷，问啥叫end of era？</p><p>我的解答是，因为一个同事昨天离职，一共工作500多天，那位同事刚来公司的时候，恰好是我坠不吼的时候。现在回过头看，简直就是一个时代的终结。</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79jw1f7y5syal9lj20t70ootau.jpg" alt=""></p><p>500天前的自己大概很难想象现在的状态。</p><p>之前一直很喜欢刘慈欣的一个观点，“美好人生的关键，在于你有没有迷上什么事物”。现在我更进一步觉得，人生的本质其实就是个对时间资源的分配。你会欣然把你的时间放到你迷上的事物上面，并且不愿意在不够喜欢的事物上多花费一分钟时间。</p><p>比如看张佳玮张公子写料理，并不是不饕餮，而是觉得一碗煮馄饨花的时间刚好符合自己对吃饭这件事的预期；<br>比如看文章里写每天要跑够40分钟以上才叫有效锻炼，并不是不想有效锻炼，只是觉得我对锻炼这事的容忍度也就仅于此（现在已改为骑车，完全不占时间，顺便就上班了=.=）；<br>比如一波一波的美国大片袭来，并不是完全不想去电影院看，只是对看电影这件事所花费的时间非常在意，口碑差的就会觉得去电影院很不值。</p><p>能挑起我兴趣的，从始至终，就是创造个什么新东西。任何种类都算。</p><p>我觉得活到现在才刚刚算活明白点儿。</p><p><br><br>现在？</p><p>听听开头提到的那首歌吧。</p><p>然后感激一切人和事。</p>]]></content>
    
    <summary type="html">
    
      一首歌，一点人生感悟。
    
    </summary>
    
      <category term="Life" scheme="http://zshowing.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://zshowing.github.io/tags/Life/"/>
    
      <category term="Music" scheme="http://zshowing.github.io/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>Bye，经理</title>
    <link href="http://zshowing.github.io/2015/05/18/bye-manager/"/>
    <id>http://zshowing.github.io/2015/05/18/bye-manager/</id>
    <published>2015-05-18T13:46:50.000Z</published>
    <updated>2016-09-25T03:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>5月12日，天高云淡，惠风和畅，正在我鱼块地和PM同学讨论问题的时候，突然看到了这么一行：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79gw1f7ve8uabo0j205509xdg1.jpg" alt=""></p><p>图中名crystal者，徐经理也，加入公司一年有余。初来时是实习生，除从事产品工作外，还负责大大小小的从数据整理到新闻运营等各种琐碎的杂活儿。半年后经理读研毕业，便顺势正式进了公司。</p><p>把聊天记录翻到头，经理加入的日期是2013年11月12日，我恰好处于一个心情的低谷期。记得这样的巧合当时还让我相当惊异了下，不过她给我的第一印象却是：</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7ve8ufur6j208708mdgi.jpg" alt=""></p><p>嗯……一个自带呆萌加成的形象呼之欲出（好委婉）。</p><p>后来一长段的聊天记录都是工作上的事情，我是个相当慢热的人，别人不多扯淡，我也不会自来熟。大概三四个月后，才慢慢地在QQ上贴个用户反馈里的乐事儿，或者吐个公司内部的槽。</p><p>总之……慢慢就成了公司里最能随便闲聊的同事。</p><p>所以，以往公司同事离职都是某一天突然发现那个人不见了，这次是唯一一次，在同事离职之前半个月，就拿到了消息。</p><p>能做点什么呢？</p><h3 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h3><p>我翻看了下手机里的照片，正巧发现了很早拍的一张午休时的抓拍：</p><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f7vehezovbj20go0m8784.jpg" alt=""></p><p>于是，一个点子出现在脑海里：我可以做个卡片嘛！<br>大概是这个样子：</p><p><img src="http://ww1.sinaimg.cn/large/5613ec79gw1f7vehez2gpj20go0oo77q.jpg" alt=""></p><h3 id="Days-in-TouchChina"><a href="#Days-in-TouchChina" class="headerlink" title="Days in TouchChina"></a>Days in TouchChina</h3><p>接着，索性又去弄了些素材，扩展成了“Days in TouchChina”系列：  </p><h4 id="Days-in-TC系列之产品部座位图"><a href="#Days-in-TC系列之产品部座位图" class="headerlink" title="Days in TC系列之产品部座位图"></a>Days in TC系列之产品部座位图</h4><p>注：头像来自设计部同事自己的设计</p><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7veheq1hwj20go0oo0u5.jpg" alt="Days in TC系列之去年的产品部座位图（头像是拿来的）">  </p><h4 id="Days-in-TC系列之桌面"><a href="#Days-in-TC系列之桌面" class="headerlink" title="Days in TC系列之桌面"></a>Days in TC系列之桌面</h4><p><img src="http://ww3.sinaimg.cn/large/5613ec79gw1f7veheycf6j20go0oodif.jpg" alt="Days in TC系列之桌面">  </p><h4 id="Days-in-TC系列之考勤卡"><a href="#Days-in-TC系列之考勤卡" class="headerlink" title="Days in TC系列之考勤卡"></a>Days in TC系列之考勤卡</h4><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7vehexq3tj20go0oojvf.jpg" alt="Days in TC系列之考勤卡">  </p><h4 id="工作照摆拍"><a href="#工作照摆拍" class="headerlink" title="工作照摆拍"></a>工作照摆拍</h4><p><img src="http://ww4.sinaimg.cn/large/5613ec79gw1f7veem1cekj21kw16oqr0.jpg" alt=""></p><h3 id="致经理"><a href="#致经理" class="headerlink" title="致经理"></a>致经理</h3><p>自己觉得简直是半成品一样的设计，但是不知道该怎么修改了……</p><p>还好，程序员做设计，没人会苛责什么。</p><p>——谨以此致经理。</p>]]></content>
    
    <summary type="html">
    
      “经理”，又叫徐经理，是以前公司的产品经理，因为比较熟，所以经常开玩笑地这么叫她。&lt;br&gt;这篇文章记叙了当时在她离职之前，我对送她的离职礼物的考虑和设计。
    
    </summary>
    
      <category term="Design" scheme="http://zshowing.github.io/categories/Design/"/>
    
    
      <category term="Design" scheme="http://zshowing.github.io/tags/Design/"/>
    
      <category term="Photoshop" scheme="http://zshowing.github.io/tags/Photoshop/"/>
    
  </entry>
  
</feed>
